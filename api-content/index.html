{"posts":[{"title":"记一次麦克风异常的排查经历","content":"复现方式 进入腾讯会议app，然后把麦克风关闭，这个时候手机上的小黄点会消失。 然后使用其他app的录音功能，比如系统的语音备忘录、QQ、微信，这个时候虽然录音正常启动，也出现小黄点，但实际上什么声音都没有。 排查过程 通过AudioQueue实现的录音，启动都没有什么错误。 然后通过LevelMeter检查数据的音量，发现全是0。 再看看AudioSession的各种接口，setActive、setCategory都是正常的。 好奇怪🤔 经过测试，这时使用微信的语音通话，是可以使用麦克风的。 此时回到腾讯会议，会出现中断的提示。 也就是说，只有使用AudioUnit才能把音频权限抢回来，然后腾讯会议收到AudioSessionInterrupt的通知，出现提示。 于是乎，我们可以自己写一个AudioUnit的录音demo，而这个之前早就写过了。 https://github.com/jayying007/iOSDemos 测试时发现，即使是AudioUnit，选择RemoteIO也是不行的，需要选择VoiceProcessingIO。 另外一个发现是，使用AudioQueue，只要把AudioSession setCategory的option AudioSessionModeVoiceChat加上，也是可以打断腾讯会议，把麦克风抢回来的。 但是话说回来，AudioUnit本身是用于通话类场景的，这里录音使用真的好吗？ 疑问 一个支线任务：如何实现关闭麦克风，右上角的小黄点消失？🤔 试了下，AudioUnit通过EnableIO把输入通道给关闭了，依然不行。 最后试了下setInputMuted这个接口，发现可行。也就是说，可以仿照腾讯会议的逻辑，屏蔽掉其他App的录音。 结论 我觉得这是苹果🍎的bug，其他App把麦克风关闭的时候无法录音，把麦克风打开的时候又可以录音。 setInputMuted这个逻辑本来是每个App单独设置的，怎么这里会影响到全部app呢。 ","link":"https://jayying007.github.io/post/ji-yi-ci-mai-ke-feng-yi-chang-de-pai-cha-jing-li/"},{"title":"iOS 显示HDR组件","content":"概述 在iOS中，我们可以显示HDR图片，播放HDR视频，但能不能显示HDR控件呢？ 比如文字、按钮、进度条这些。在系统相册中，播放HDR视频时，你会发现进度条也有HDR效果。 HDR图片 在此之前，我们先回顾一下显示HDR图片的方法。 NSString *imagePath = [[NSBundle mainBundle] pathForResource:@&quot;IMG_4167.HEIC&quot; ofType:nil]; UIImage *image = [UIImageReader.defaultReader imageWithContentsOfFileURL:[NSURL fileURLWithPath:imagePath]]; UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(60, 120, 120, 120)]; imageView.image = image; imageView.preferredImageDynamicRange = UIImageDynamicRangeHigh; 那么，是不是用HDR图片生成UI控件就好了？ 理论上看起来是可行的，不过实际上文本要怎么处理？ HDR 控件 经过一番搜查，在Github上发现了这个项目： GitHub - tsuzukihashi/EDR_Swift: I want to use EDR features easily. 作者是用CoreImage的方式，生成了HDR的二维码和条形码，然后用MetalKit将其渲染到屏幕上。 这种方法在一次WWDC的分享中有提及过： Display EDR content with Core Image, Metal, and SwiftUI - WWDC22 - Videos - Apple Developer 查看CoreImage的相关接口，发现了生成文本图片的方式。 @interface CIFilter (Builtins) + (CIFilter&lt;CITextImageGenerator&gt;*) textImageGeneratorFilter; + (CIFilter&lt;CIAttributedTextImageGenerator&gt;*) attributedTextImageGeneratorFilter; @end 但是这两个接口无法处理文本截断的场景，CoreImage没有宽度这些信息。 实际上，我们要的是CIImage，所以可以通过Core Graphics绘制文本为CGImage，再转换成CIImage就可以了。 于是乎，渲染HDR Label便成为了可能。 可以仿照上面的项目实现，具体逻辑如下： #import &lt;Foundation/Foundation.h&gt; #import &lt;MetalKit/MetalKit.h&gt; @interface MetalRender : NSObject &lt;MTKViewDelegate&gt; - (instancetype)initWithImageProvider:(CIImage * (^)(CGFloat contentScaleFactor, CGFloat headroom))imageProvider; @property (nonatomic) id&lt;MTLDevice&gt; device; @end #import &quot;MetalRender.h&quot; @interface MetalRender () @property (nonatomic) id&lt;MTLCommandQueue&gt; commandQueue; @property (nonatomic) CIContext *renderContext; @property (nonatomic) CIImage * (^imageProvider)(CGFloat contentScaleFactor, CGFloat headroom); @end @implementation MetalRender - (instancetype)initWithImageProvider:(CIImage * (^)(CGFloat, CGFloat))imageProvider { self = [super init]; if (self) { self.imageProvider = imageProvider; self.device = MTLCreateSystemDefaultDevice(); self.commandQueue = [self.device newCommandQueue]; self.renderContext = [CIContext contextWithMTLCommandQueue:self.commandQueue options:@{ kCIContextName : @&quot;MetalRender&quot;, kCIContextCacheIntermediates : @(YES), kCIContextAllowLowPower : @(YES) }]; } return self; } - (void)drawInMTKView:(MTKView *)view { // Create a new command buffer for each render pass to the current drawable. id&lt;MTLCommandBuffer&gt; commandBuffer = [_commandQueue commandBuffer]; id&lt;CAMetalDrawable&gt; drawable = view.currentDrawable; if (drawable == nil) { return; } CGSize drawSize = view.drawableSize; CGFloat contentScaleFactor = view.contentScaleFactor; CIRenderDestination *destination = [[CIRenderDestination alloc] initWithWidth:drawSize.width height:drawSize.height pixelFormat:view.colorPixelFormat commandBuffer:commandBuffer mtlTextureProvider:^id&lt;MTLTexture&gt; { return drawable.texture; }]; if (@available(iOS 16.0, *)) { CGFloat headroom = view.window.screen.currentEDRHeadroom; CIImage *image = self.imageProvider(contentScaleFactor, headroom); CGRect iRect = [image extent]; CGRect backBounds = CGRectMake(0, 0, drawSize.width, drawSize.height); CGFloat shiftX = round((backBounds.size.width + iRect.origin.x - iRect.size.width) * 0.5); CGFloat shiftY = round((backBounds.size.height + iRect.origin.y - iRect.size.height) * 0.5); image = [image imageByApplyingTransform:CGAffineTransformMakeTranslation(shiftX, shiftY)]; [_renderContext startTaskToRender:image fromRect:backBounds toDestination:destination atPoint:CGPointZero error:nil]; } [commandBuffer presentDrawable:drawable]; [commandBuffer commit]; } - (void)mtkView:(MTKView *)view drawableSizeWillChange:(CGSize)size { } @end #import &lt;MetalKit/MetalKit.h&gt; #import &quot;MetalRender.h&quot; @interface MetalView : MTKView - (instancetype)initWithFrame:(CGRect)frame render:(MetalRender *)render; @end #import &quot;MetalView.h&quot; @interface MetalView () @property (nonatomic) MetalRender *render; @end @implementation MetalView - (instancetype)initWithFrame:(CGRect)frame render:(MetalRender *)render { self = [super initWithFrame:frame device:render.device]; if (self) { self.render = render; self.preferredFramesPerSecond = 10; self.framebufferOnly = NO; self.delegate = self.render; self.backgroundColor = UIColor.clearColor; CAMetalLayer *layer = (CAMetalLayer *)self.layer; if (@available(iOS 16.0, *)) { layer.wantsExtendedDynamicRangeContent = YES; } layer.colorspace = CGColorSpaceCreateWithName(kCGColorSpaceExtendedLinearSRGB); self.colorPixelFormat = MTLPixelFormatRGBA16Float; } return self; } @end #import &lt;UIKit/UIKit.h&gt; @interface EDRLabel : UIView @property (nonatomic) NSString *text; - (void)applyStyleWithLabel:(UILabel *)label; @end #import &quot;EDRLabel.h&quot; #import &quot;MetalView.h&quot; #import &lt;CoreImage/CIFilterBuiltins.h&gt; @interface EDRLabel () @property (nonatomic) MetalView *metalView; @property (nonatomic) CIImage *ciImage; @property (nonatomic) UIFont *font; @property (nonatomic) UIColor *textColor; @property (nonatomic) NSLineBreakMode lineBreakMode; @property (nonatomic) NSInteger numberOfLines; @end @implementation EDRLabel - (instancetype)initWithFrame:(CGRect)frame { self = [super initWithFrame:frame]; if (self) { __weak typeof(self) weakSelf = self; MetalRender *render = [[MetalRender alloc] initWithImageProvider:^CIImage *(CGFloat contentScaleFactor, CGFloat headroom) { __strong typeof(self) strongSelf = weakSelf; CIImage *image = strongSelf.ciImage; CGFloat red, green, blue, alpha; [strongSelf.textColor getRed:&amp;red green:&amp;green blue:&amp;blue alpha:&amp;alpha]; CGColorSpaceRef colorSpace = CGColorSpaceCreateWithName(kCGColorSpaceExtendedLinearSRGB); CIColor *maxFillColor = [CIColor colorWithRed:headroom * red green:headroom * green blue:headroom * blue alpha:alpha colorSpace:colorSpace]; CIImage *fillImage = [CIImage imageWithColor:maxFillColor]; CIFilter&lt;CIBlendWithMask&gt; *maskFilter = [CIFilter blendWithAlphaMaskFilter]; maskFilter.maskImage = image; maskFilter.inputImage = fillImage; return [maskFilter.outputImage imageByCroppingToRect:CGRectMake(0, 0, strongSelf.width * contentScaleFactor, strongSelf.height * contentScaleFactor)]; }]; self.metalView = [[MetalView alloc] initWithFrame:frame render:render]; [self addSubview:self.metalView]; self.userInteractionEnabled = NO; } return self; } - (void)applyStyleWithLabel:(UILabel *)label { self.text = label.text; self.font = label.font; self.textColor = label.textColor; self.lineBreakMode = label.lineBreakMode; self.numberOfLines = label.numberOfLines; } - (void)layoutSubviews { [super layoutSubviews]; self.metalView.frame = self.bounds; } - (void)setFrame:(CGRect)frame { BOOL sizeChange = self.bounds.size.width != frame.size.width || self.bounds.size.height != frame.size.height; if (sizeChange) { _ciImage = nil; } [super setFrame:frame]; } - (void)setText:(NSString *)text { _text = text; _ciImage = nil; } - (CIImage *)ciImage { if (_ciImage == nil) { UILabel *label = [[UILabel alloc] initWithFrame:self.bounds]; label.text = self.text; label.font = self.font; label.lineBreakMode = self.lineBreakMode; label.numberOfLines = self.numberOfLines; UIGraphicsImageRenderer *render = [[UIGraphicsImageRenderer alloc] initWithBounds:label.bounds]; UIImage *image = [render imageWithActions:^(UIGraphicsImageRendererContext *_Nonnull rendererContext) { [label.layer renderInContext:rendererContext.CGContext]; }]; _ciImage = [[CIImage alloc] initWithImage:image]; } return _ciImage; } @end 最难的文本解决了，那实现HDR的UILabel、UIButton、UISlider就不是太复杂的事情了。这里不再赘述。 HDR Color 上面这种方式还是挺曲折的，而iOS 26迎来了新接口，可以直接把UIColor设置为HDR模式，这样对于UILabel、UIButton的接入就更简单了。 What’s new in UIKit - WWDC25 - Videos - Apple Developer 现阶段Xcode还没有iOS 26的SDK，想要尝鲜的可以通过runtime的形式调用到。 - (UIColor *)hdrColorWithHeadroom:(CGFloat)headroom { SEL sel = NSSelectorFromString(@&quot;colorWithRed:green:blue:alpha:linearExposure:&quot;); if ([UIColor.class respondsToSelector:sel] == NO) { return self; } CGFloat red = 1; CGFloat green = 1; CGFloat blue = 1; CGFloat alpha = 1; CGFloat linearExposure = headroom; [self getRed:&amp;red green:&amp;green blue:&amp;blue alpha:&amp;alpha]; NSMethodSignature *signature = [UIColor methodSignatureForSelector:sel]; NSInvocation *invocation = [NSInvocation invocationWithMethodSignature:signature]; [invocation setTarget:UIColor.class]; [invocation setSelector:sel]; [invocation setArgument:&amp;red atIndex:2]; [invocation setArgument:&amp;green atIndex:3]; [invocation setArgument:&amp;blue atIndex:4]; [invocation setArgument:&amp;alpha atIndex:5]; [invocation setArgument:&amp;linearExposure atIndex:6]; [invocation invoke]; UIColor *__unsafe_unretained color = nil; [invocation getReturnValue:&amp;color]; return color; } ","link":"https://jayying007.github.io/post/ios-xian-shi-hdr-zu-jian/"},{"title":"跨平台网络框架mars浅析","content":"https://github.com/Tencent/mars Mars 是什么 Mars 是微信官方的终端基础组件, 是一个业务性无关,平台性无关 使用 C++ 编写的基础组件。 它主要包括以下几个部分： Comm：基础库，包括 socket、线程、消息队列、协程等基础工具； Xlog：通用日志模块，充分考虑移动终端的特点，提供高性能、高可用、安全性、容错性的日志功能 SDT：网络诊断模块； STN：信令传输网络模块，负责终端与服务器的小数据信令通道。包含了微信终端在移动网络上的大量优化经验与成果，经历了微信海量用户的考验。 这些介绍 Github 上都有，我就不重复了。 给纯小白的说明 说真的，如果对网络编程不了解，上面那段话估计是看不明白的，这里再简单说明一下。 一般来说，客户端和后台通过 TCP 三次握手建立连接 这组连接通过（IP1,Socket1,IP2,Socket2）唯一标识， 你想给后台发消息，就往这个 Socket 写数据。你想从后台收消息，就从这个 Socket 读数据。 常见的通信方式有两种： 客户端请求数据，后台返回； 后台主动推数据； 其中，想要让后台在需要的时候发消息给你，就得保持 Socket 一直连接着，即所谓的长连接。而前面那种一来一回的，就无所谓短连接还是长连接了。 其实还有客户端给后台发通知的场景，只不过这种比较少见。 例如微信里面的「对方正在输入」，就是用这种能力实现的。 网络上传输的只是单纯的二进制数据，具体代表什么含义就看客户端跟后台协商的结果了。就像 TCP 协议建立在 IP 协议的基础之上，客户端和后台间的协议建立在 TCP 协议之上，这个学过计算机网络的都懂。 socket 编程对应的系统调用接口如下 到这里，总算可以知道 Mars 是什么了。简单说，Mars 就是对上面 Socket 建立的封装，由它负责建立跟后台的连接以及数据读写。 关于官方 Demo 毕竟是微信推出的，提供的 demo 是基于聊天场景设计的。 关于 IM 系统，相信大部分人在上大学时都做过玩具项目了。 比如我的：https://github.com/jayying007/chatting-room 这里要吐槽一点是，Github 上的 demo 基本是运行不起来的，我经历了九九八十一难才搞定。 Server 端和 iOS 端都有问题： Server 端的主要问题是 Gradle 版本比较老，我本地的 JDK 版本比较新，这里通过降低到 JDK8 解决； iOS 端主要问题是新旧版本符号有所变更，这个根据报错信息逐步修改解决。 解决的过程因机器而异，所以我也不打算说明，应该没有人不会 Google 吧？ iOS Demo 分析 核心结构如下： 其中，NetworkService 负责设置启动 mars，并接受 mars 回调的数据，传递给上层 NetworkEvent。 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { [NetworkService sharedInstance].delegate = [[NetworkEvent alloc] init]; [[NetworkService sharedInstance] setCallBack]; [[NetworkService sharedInstance] createMars]; [[NetworkService sharedInstance] setClientVersion:200]; [[NetworkService sharedInstance] setLongLinkAddress:@&quot;192.168.1.101&quot; port:8081]; [[NetworkService sharedInstance] setShortLinkPort:8080]; [[NetworkService sharedInstance] reportEvent_OnForeground:YES]; [[NetworkService sharedInstance] makesureLongLinkConnect]; [[NetworkStatus sharedInstance] Start:[NetworkService sharedInstance]]; return YES; } 一次请求的过程 以 PingServerController 中的代码为例。 点击 Click 时，客户端创建了一个 CGITask，传递给 NetworkService，并把自己作为监听者。 - (IBAction)onButtonClick:(id)sender forEvent:(UIEvent *)event { CGITask *helloCGI = [[CGITask alloc] initAll:ChannelType_All AndCmdId:kSayHello AndCGIUri:@&quot;/mars/hello&quot; AndHost:@&quot;192.168.1.101&quot;]; [[NetworkService sharedInstance] startTask:helloCGI ForUI:self]; } 这个 CGITask 只是客户端对数据的封装，在 NetworkService 层会解析为 mars 的一个 Task，然后启动这个 Task。 每次创建 Task 都会生成一个唯一的 taskid，之后将这些上下文信息注册到 NetworkEvent 中。 - (int)startTask:(CGITask *)task ForUI:(id&lt;UINotifyDelegate&gt;)delegateUI { Task ctask; ctask.cmdid = task.cmdid; ctask.channel_select = task.channel_select; ctask.cgi = std::string(task.cgi.UTF8String); ctask.shortlink_host_list.push_back(std::string(task.host.UTF8String)); ctask.user_context = (__bridge void*)task; NSString *taskIdKey = [NSString stringWithFormat:@&quot;%d&quot;, ctask.taskid]; [_delegate addObserver:delegateUI forKey:taskIdKey]; [_delegate addCGITasks:task forKey:taskIdKey]; mars::stn::StartTask(ctask); return ctask.taskid; } 接下来 Task 启动，要真正发送数据了，mars 通过 callback 来索取数据 // StnCallBack bool StnCallBack::Req2Buf(uint32_t _taskid, void* const _user_context, const std::string&amp; _user_id, AutoBuffer&amp; _outbuffer, AutoBuffer&amp; _extend, int&amp; _error_code, const int _channel_select, const std::string&amp; host) { NSData* requestData = [[NetworkService sharedInstance] Request2BufferWithTaskID:_taskid userContext:_user_context]; if (requestData == nil) { requestData = [[NSData alloc] init]; } _outbuffer.AllocWrite(requestData.length); _outbuffer.Write(requestData.bytes,requestData.length); return requestData.length &gt; 0; } // NetworkService - (NSData*)Request2BufferWithTaskID:(uint32_t)tid userContext:(const void *)context { CGITask *task = (__bridge CGITask *)context; return [_delegate Request2BufferWithTaskID:tid task:task]; } // NetworkEvent - (NSData*)Request2BufferWithTaskID:(uint32_t)tid task:(CGITask *)task { NSData* data = NULL; NSString *taskIdKey = [NSString stringWithFormat:@&quot;%d&quot;, tid]; id&lt;UINotifyDelegate&gt; uiObserver = [controllers objectForKey:taskIdKey]; if (uiObserver != nil) { data = [uiObserver requestSendData]; } return data; } // PingServerController - (NSData*)requestSendData { HelloRequest *helloRequest = [HelloRequest new]; helloRequest.user = [self username]; helloRequest.text = @&quot;Hello world&quot;; NSData *data = [helloRequest data]; return data; } 经过层层传递，最后来到了 PingServerController，得到一个 HelloRequest 的序列化数据。这里的业务层数据是一个 protobuf 对象，也是网络编程常用的序列化方式，关于 protobuf 的介绍可以看以前写的博客。 因为这是个有来有回的请求，所以后台还会回数据给客户端，也是 mars 通过 callback 来返回数据。 // StnCallBack int StnCallBack::Buf2Resp(uint32_t _taskid, void* const _user_context, const std::string&amp; _user_id, const AutoBuffer&amp; _inbuffer, const AutoBuffer&amp; _extend, int&amp; _error_code, const int _channel_select) { int handle_type = mars::stn::kTaskFailHandleNormal; NSData* responseData = [NSData dataWithBytes:(const void *) _inbuffer.Ptr() length:_inbuffer.Length()]; NSInteger errorCode = [[NetworkService sharedInstance] Buffer2ResponseWithTaskID:_taskid ResponseData:responseData userContext:_user_context]; if (errorCode != 0) { handle_type = mars::stn::kTaskFailHandleDefault; } return handle_type; } // NetworkService - (NSInteger)Buffer2ResponseWithTaskID:(uint32_t)tid ResponseData:(NSData *)data userContext:(const void *)context { CGITask *task = (__bridge CGITask *)context; return [_delegate Buffer2ResponseWithTaskID:tid responseData:data task:task]; } // NetworkEvent - (NSInteger)Buffer2ResponseWithTaskID:(uint32_t)tid responseData:(NSData *)data task:(CGITask *)task { int returnType = 0; NSString *taskIdKey = [NSString stringWithFormat:@&quot;%d&quot;, tid]; id&lt;UINotifyDelegate&gt; uiObserver = [controllers objectForKey:taskIdKey]; if (uiObserver != nil) { returnType = [uiObserver onPostDecode:data]; } else { returnType = -1; } return returnType; } // PingServerController - (int)onPostDecode:(NSData*)responseData { helloResponse = [HelloResponse parseFromData:responseData error:nil]; if ([helloResponse hasErrmsg]) { dispatch_async(dispatch_get_main_queue(), ^{ UIAlertController *alert = [UIAlertController alertControllerWithTitle:nil message:helloResponse.errmsg preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;OK&quot; style:UIAlertActionStyleDefault handler:nil]]; [self presentViewController:alert animated:YES completion:nil]; }); LOG_INFO(kModuleViewController, @&quot;recv hello response: %@&quot;, helloResponse.errmsg); } return helloResponse.retcode == 0 ? 0 : -1; } 一次 Push 的过程 为了测试这个过程，需要准备两台手机。这里以 TopicViewController 中的代码为例。 首先一台手机发送消息，过程和上面的类似，会有 request 和 response。 // request时调用 - (NSData*)requestSendData { SendMessageRequest *sendMsgRequest = [SendMessageRequest new]; sendMsgRequest.from = [self username]; sendMsgRequest.to = @&quot;all&quot;; sendMsgRequest.text = _textField.text; sendMsgRequest.accessToken = @&quot;123456&quot;; sendMsgRequest.topic = _conversation.topic; LOG_INFO(kModuleViewController, @&quot;send msg to topic:%@&quot;, _conversation.notice); NSData* data = [sendMsgRequest data]; dispatch_async(dispatch_get_main_queue(), ^{ _textField.text = @&quot;&quot;; }); return data; } // response时调用 - (int)onPostDecode:(NSData*)responseData { SendMessageResponse *sendMsgResponse = [SendMessageResponse parseFromData:responseData error:nil]; dispatch_async(dispatch_get_main_queue(), ^{ NSString *recvtext = [NSString stringWithFormat:@&quot;%@ : %@&quot;, sendMsgResponse.from, sendMsgResponse.text]; [self.messages addObject:recvtext]; [self.tableView reloadData]; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:self.messages.count-1 inSection:0]; [self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; }); return sendMsgResponse.errCode == 0 ? 0 : -1; } 在进入 TopicViewController 时，注册了 PushObserver - (void)viewDidLoad { [super viewDidLoad]; // 略... [[NetworkService sharedInstance] addPushObserver:self withCmdId:kPushMessageCmdId]; } 这样当后台 Push 数据时，就能找到对应的处理者。这样另一台手机就能收到消息了。 // StnCallBack void StnCallBack::OnPush(const std::string&amp; _channel_id, uint32_t _cmdid, uint32_t _taskid, const AutoBuffer&amp; _body, const AutoBuffer&amp; _extend) { if (_body.Length() &gt; 0) { NSData* recvData = [NSData dataWithBytes:(const void *) _body.Ptr() length:_body.Length()]; [[NetworkService sharedInstance] OnPushWithCmd:_cmdid data:recvData]; } } // NetworkService - (void)OnPushWithCmd:(NSInteger)cid data:(NSData *)data { return [_delegate OnPushWithCmd:cid data:data]; } // NetworkEvent - (void)OnPushWithCmd:(NSInteger)cid data:(NSData *)data { id&lt;PushNotifyDelegate&gt; pushObserver = [pushrecvers objectForKey:[NSString stringWithFormat:@&quot;%d&quot;, cid]]; if (pushObserver != nil) { [pushObserver notifyPushMessage:data withCmdId:cid]; } } // TopicViewController - (void)notifyPushMessage:(NSData*)pushData withCmdId:(int)cmdId { MessagePush* messagePush = [MessagePush parseFromData:pushData error:nil]; if (messagePush != nil) { dispatch_async(dispatch_get_main_queue(), ^{ NSString *recvtext = [NSString stringWithFormat:@&quot;%@ : %@&quot;, messagePush.from, messagePush.content]; [self.messages addObject:recvtext]; [self.tableView reloadData]; NSIndexPath *indexPath = [NSIndexPath indexPathForRow:self.messages.count-1 inSection:0]; [self.tableView scrollToRowAtIndexPath:indexPath atScrollPosition:UITableViewScrollPositionBottom animated:YES]; }); } } 画成图大概长这样： 写到最后 这里要提个醒，如果你以为网络上传输的就是纯 HelloRequest、HelloResponse、MessagePush 这样的数据，那说明你还没完全理解。 毕竟这里还有个疑问，怎么区分后台返回的数据是 HelloResponse 还是 MessagePush🤔。 回想前面创建 CGITask 的过程，其实还有 cmdid 这个东西。 - (IBAction)onButtonClick:(id)sender forEvent:(UIEvent *)event { CGITask *helloCGI = [[CGITask alloc] initAll:ChannelType_All AndCmdId:kSayHello AndCGIUri:@&quot;/mars/hello&quot; AndHost:@&quot;192.168.1.101&quot;]; [[NetworkService sharedInstance] startTask:helloCGI ForUI:self]; } 这样，客户端在请求时把这个 cmdid 也带上，后台就知道客户端请求的是什么内容。 后台返回时把 cmdid 带上，客户端就知道后台返回的是什么内容。 在 Demo 中，客户端和后台之间的传输协议如下： 客户端这部分代码在 longlink_packer.cc 中 void (*longlink_pack)(uint32_t _cmdid, uint32_t _seq, const AutoBuffer&amp; _body, const AutoBuffer&amp; _extension, AutoBuffer&amp; _packed, longlink_tracker* _tracker) = [](uint32_t _cmdid, uint32_t _seq, const AutoBuffer&amp; _body, const AutoBuffer&amp; _extension, AutoBuffer&amp; _packed, longlink_tracker* _tracker) { __STNetMsgXpHeader st = {0}; st.head_length = htonl(sizeof(__STNetMsgXpHeader)); st.client_version = htonl(sg_client_version); st.cmdid = htonl(_cmdid); st.seq = htonl(_seq); st.body_length = htonl(_body.Length()); _packed.AllocWrite(sizeof(__STNetMsgXpHeader) + _body.Length()); _packed.Write(&amp;st, sizeof(st)); if (NULL != _body.Ptr()) _packed.Write(_body.Ptr(), _body.Length()); _packed.Seek(0, AutoBuffer::ESeekStart); }; 服务器这部分代码在 NetMsgHeader.java 中 public byte[] encode() throws InvalidHeaderException { if (body == null &amp;&amp; cmdId != CMDID_NOOPING &amp;&amp; cmdId != CMDID_NOOPING_RESP) { throw new InvalidHeaderException(&quot;invalid header body&quot;); } final int headerLength = FIXED_HEADER_SKIP + (options == null ? 0 : options.length); final int bodyLength = (body == null ? 0 : body.length); final int packLength = headerLength + bodyLength; final ByteArrayOutputStream baos = new ByteArrayOutputStream(packLength); try { final DataOutputStream dos = new DataOutputStream(baos); dos.writeInt(headerLength); dos.writeInt(CLIENTVERSION); dos.writeInt(cmdId); dos.writeInt(seq); dos.writeInt(bodyLength); if (options != null) { dos.write(options); } if (body != null) { dos.write(body); } } catch (IOException e) { e.printStackTrace(); } finally { try { baos.close(); } catch (IOException e) { e.printStackTrace(); } } return baos.toByteArray(); } 最后的最后，我还要插一句。这个协议是客户端跟后台协商的，每个业务定的都不一样，微信也不是这样搞的。具体怎么定义取决于自身业务，更好的设计是减少传输数据大小，又能有扩展性，更安全。 其他 如果你对 mars 的源码有兴趣，可以参考下面的博客 Tencent Mars 源码解析 ","link":"https://jayying007.github.io/post/跨平台网络框架mars浅析/"},{"title":"[转] 游戏中的AI-行为树","content":"https://lifan.tech/2020/02/15/game/behavior-tree/ 游戏里有不少算法，如本文的行为树，以及还有排行榜的排序算法、寻路算法、物体碰撞，如果你是做 3D 引擎的，还得懂图形学、物理学、数学... 这里的行为树虽然在 iOS 中基本用不到，但跟它关联的状态机还是有可能的。 游戏中，常见用 AI 实现方式有 2 种，状态机和行为树。下面主要简介绍行为树，行为树是用一棵多叉树来表示 AI，树的中间节点为控制节点控制着 AI 的执行流程，叶子节点为行为节点，描述了 AI 的具体行为。 一、案例描述 山贼的 AI 需求描述如下： 视野内没有敌人则在一定范围内巡逻 视野出现敌人则走过去攻击敌人 当自己血量 &lt; 20% 则逃跑 下面将分别用状态机和行为树来描述山贼的 AI 二、状态机 上图是用状态机来描述山贼的 AI, 目前来看状态机的逻辑还是非常清晰，代码实现也比较简单。但随着项目的推进，策划随时可能增加需求。假如现在需要加一个 “石化”状态，描述如下： 在逃跑的过程中，如果追击者数量&gt;2，则立即把自己石化，持续 5s，此时自己不能被攻击也不能攻击目标 在状态机中加入“石化”状态时，我们需要考虑它跟现有每个状态之间是否有联系，输入输出状态分别有哪些。 1.1 状态机存在的不足 在项目中随时可能增加新状态、减少状态或者改变状态之间的迁移关系，如果状态越来越多，任何一点小修改都会产生很大的工作量，代码中会出现大量的判断跳转，代码的逻辑会变得越来越混乱，如果负责状态机的同事离职了，这会带来很大的问题。 行为树的出现从根本上解决了这些问题，它把每个行为作为一个原子项，提供给策划编辑，让策划来决定 AI 的执行流程，程序只需要集中精力根据需求增加新的行为，不用关心具体流程。用种方式，程序的工作会得到很大程度的解放，即使有一天交给其他同事维护也比较容易。 三、行为树 行为树是由控制节点、装饰节点、行为节点组成的一棵 n 叉树，中间节点一般为控制节点和装饰节，用于控制行为树的执行流程，它们相对固定，一旦确定几乎不会变化；叶子节点由行为节点或条件节点组成，它实现了 AI 中的各种行为，程序的大部分工作都是丰富行为节点。需要注意的是，行为树的每个节点都有一个返回值，它们分别是： 成功（Success） 失败（failed） 运行中（running）：表示当前帧没有执行完成、下帧继续执行。 下面列出了行为树常用的节点类型，主要用于说明行为树的原理，类型可能不全面；但只要明白了原理，根据项目需求增加类型即可。 1.1 控制类节点 控制节点一般为中间节点，用于控制行为树的执行流程，决定了其子节点是以顺序、并行、随机或其它方式执行。 顺序节点（Sequences） 依次执行所有子节点，若当前子节点返回成功，则继续执行下一个子节点；若子当前节点返回失败，则中断后续子节点的执行，并把结果返回给父节点。 如下图所求：节点 1 返回成功，继续执行节点 2；节点 2 返回失败，则把结果返回给 Sequences 的父节点，节点 3 并不会执行。顺序节点相当于 and 语义。 选择节点（Selector） 依次执行所有子节点，若当前子节点返回成功，则中断后续节点运行，并把结果返回给父节点。如下图所示： 相当于 or 语义 并行节点（Parallel） 依次执行所有子节点，无论失败与否，都会把所有子节点执行一遍。至于 Parallel 节点该返回什么值给父节点，这要看需求。比如：成功数 &gt; 失败数返回成功，否则返回失败。 如下图所示： 随机节点（Random） 随机选择一个子节点来运行。 记忆节点（MemSequences、MemSelector） 功能和顺序节点、选择节点类似，唯一不同是会保存当前执行进度（比如：保存当前子节点索引），下一帧继续执行当前节点，如果当前节点是中间节点，则会跳过前面的节点。 1.2 装饰节点（Decorator） 逆变节点（Inverter）：对子节点的返回值取反，相当于 not 语义，它只会有一个子节点。 成功节点（Succeeder）：不管其子节点返回何值，都会返回 Success 给父节点 重复节点（Repeater）：重复执行 n 次子节点。 重复直至失败节点（Repeat Until Fail）：重复执行子节点，直到失败为上；同样也有类似的重复直至成功节点这里就不列出了。 执行一段时间（MaxTime）：重复执行子节点一段时间 节点的类型是灵活多变的，不同的项目有不同的需求，上面只列出了常用的。 1.3 行为节点（Action） 行为节点都是叶节点，控制节点用于控制行为执行的流程，行为节点则表示具体功能，比如：战斗，逃跑，巡逻等。它至少包含两个函数： Init:用于初始化节点，比如读取配置数据初始化当前节点，只会执行一次。 OnTick:每一帧都会执行，节点的主要逻辑都在此函数中实现或调用。 1.3.1 行为节点代码实现 这是一个在指定范围内查找道具的行为节点例子（Ation）: //节点结构 type FindItem struct { b3core.Action index string etype EntityType dis float32 } //初始化函数，参数setting为节点的配置数据 //此函数在加载节点时调用 func (this *FindItem) Initialize(setting *b3config.BTNodeCfg) { this.Action.Initialize(setting) this.index = setting.GetPropertyAsString(&quot;index&quot;) //道具枚举用于缓存道具的key this.etype = EntityType(setting.GetPropertyAsInt(&quot;etype&quot;))//道具类型 this.dis = float32(setting.GetProperty(&quot;range&quot;))//查找范围 } //遍历节点时，此函数会被调用，每个节点都有OnTick函数 func (this *FindItem) OnTick(tick *b3core.Tick) b3.Status { f := tick.GetTarget().(*Fighter) //玩家对象 tick.Blackboard.Set(this.index, int32(0), &quot;&quot;, &quot;&quot;) //清空老数据 ball := f.FindNearItem(this.dis, this.etype) //在附近搜索道具 if nil == ball {//如果没找到，向父节点返回FAILURE return b3.FAILURE } id := ball.GetID() //获取道具id tick.Blackboard.Set(this.index, id, &quot;&quot;, &quot;&quot;) //缓存道具id return b3.SUCCESS//向父节点返回SUCCESS //因为行为树的节点返回值必须是FAILURE、SUCCESS、RUNNING, 所以Tick中产生的结果只能通过其它方式传回去，比如例子中的Blackboard } 1.3.2 用行为树表示山贼 AI 用行为树来表示的山贼 AI，并加上了“石化”需求，下图黄色部分： 需求描述：在逃跑的过程中，如果追击者数量&gt;2，则立即把自己石化，持续 5s，此时自己不能被攻击也不能攻击目标。 对于程序来说，只需要写”石化”的逻辑即可，至于这个行为用在哪里，执行顺序以及和其它行为的关系，则由策划来决定。在本例中，条件判断其实可以放在行为节里，这里把它独立出来主要是为了方便表达。 四、状态机与行为树比较 1.1 状态机 优点：实现简单、执行效率高。 缺点：随着状态数量的增多，状态之间的关系会越来越复杂，代码变得难以维护。 1.2 行为树 优点：结构清晰、节点间关系弱，程序大部分工作是丰富行为节点，AI 流程交由策划完成。 缺点：每次 tick 都会遍历整棵行为树(Mem 子节点除外)，若树的深度很深，效率将变得低下。 五、关于状态机行为树的思考 从状态机和行为树的特征可以看出，状态机和行为树都存在明显的优缺点。我们可不可以只取它们的优点呢？ 在游戏中，若主动怪的视野范围内没有目标它的行为是很简单的，一般会在一定范围内巡逻。如果用行为树，不管视野内有没有人，每帧都会遍历所有非行为节点，这造成了很大的资源浪费。 如果用状态机实现巡逻、死亡、逃跑，进入战斗后的行为用行为树，这会是一个有效的优化。尤其是怪物很多时，大部分时间段，大部分怪都处于巡逻或 idle 状态，完全没有必要遍历行为树。 如果项目的 AI 比较简单，比如小游戏之类的。用状态机是个不错的选择。 ","link":"https://jayying007.github.io/post/[转] 游戏中的AI-行为树/"},{"title":"FastImageCache框架分析","content":"https://github.com/path/FastImageCache 简介 FastImageCahce 顾名思义，用于图像缓存。 传统的图像加载性能比较低，在列表滚动场景下特别容易掉帧。而 FastImageCache 就是专门针对列表滚动场景做的性能优化。 对于两者的性能对比，你可以参考官方的 Demo 工程去感受一下。 图像加载流程 +[UIImage imageWithContentsOfFile:]通过 Image I/O 接口创建了一个CGImageRef，这个时候图像还没有解码。而且利用内存映射，数据也没加到内存中。 将得到的图像赋值到 UIImageView 中。 CATransaction 捕捉到 Layer Tree 发生变更。 在下一个 RunLoop 中，Core Animation 提交该 CATransaction，根据 UIImage 解码与否，会有以下步骤： 分配 Buffer 用于解码相关操作 将数据从磁盘加载到内存中 解码图片成位图，这个过程发生在 CPU 得到的位图会被 Core Animation 用于接下来的渲染 FastImageCache 如何优化的 内存映射 如果每张图片都存在不同的位置，那么将它们从磁盘读到内存中就会涉及多次 IO。 FastImageCache 则将它们都存在同一个文件中，然后利用 mmap 技术，你需要读取哪张图片，就会在常量时间内计算出其位置，然后读取。 这种技术似乎在 2D 游戏贴图中还挺常用的。 解码数据 FastImageCache 存到文件中的都是已经解码的数据，所以后续不再需要解码。 当然，这是一个很典型的空间换时间的策略。 字节对齐 Core Animation 在提交图像数据时，如果其没有字节对齐，则会触发一次拷贝进行对齐。 一个合适的对齐数值是图片每行的字节数要对齐8 pixels x bytes per pixel，对于常见的 ARGB 图片，就是 64。 FastImageCache 如何设计的 前面提到把所有图片数据都存到同一个文件上，大概长这么个样子： 但是光有这个文件还不够，比如你不知道第三张图片的偏移量，也不知道图片对应的是什么东西。 解决图片偏移量的问题，FastImageCache 是限制了每一张图片都是一样的大小，包括图片的渲染格式等信息，这些信息存储在 ImageFormat 中。知道图片的大小，计算偏移量就简单多了。 解决图片是什么的问题，自然是要给每个图片分配一个 UUID，代码中每个图片模型都是 FICEntity @protocol FICEntity &lt;NSObject&gt; /** A string that uniquely identifies this entity. @discussion Within each image table, each entry is identified by an entity's UUID. Ideally, this value should never change for an entity. For example, if your entity class is a person model, its UUID might be an API-assigned, unchanging, unique user ID. No matter how the properties of the person change, its user ID should never change. */ @property (nonatomic, copy, readonly) NSString *fic_UUID; @end 另外还要记录哪个 UUID 是文件的第几个图片，这部分信息被记录到另一个文件中，称为 Meta 文件。 总体上看，每个 ImageFormat 对应一种图片格式的文件存储，代码中用 ImageTable 维护每个图片文件。 缓存的接口无非就是 CRUD 那一套。 /** `FICImageTable` is the primary class that efficiently stores and retrieves cached image data. Image tables are defined by instances of `&lt;FICImageFormat&gt;`. Each image table is backed by a single file on disk that sequentially stores image entry data. All images in an image table are either opaque or not and have the same dimensions. Therefore, when defining your image formats, keep in mind that you cannot mix image dimensions or whether or not an image is opaque. */ @interface FICImageTable : NSObject ///------------------------------------------------ /// @name Storing, Retrieving, and Deleting Entries ///------------------------------------------------ /** Stores new image entry data in the image table. @param entityUUID The UUID of the entity that uniquely identifies an image table entry. Must not be `nil`. @param sourceImageUUID The UUID of the source image that represents the actual image data stored in an image table entry. Must not be `nil`. @param imageDrawingBlock The drawing block provided by the entity that actually draws the source image into a bitmap context. Must not be `nil`. @discussion Objects conforming to `&lt;FICEntity&gt;` are responsible for providing an image drawing block that does the actual drawing of their source images to a bitmap context provided by the image table. Drawing in the provided bitmap context writes the uncompressed image data directly to the image table file on disk. @note If any of the parameters to this method are `nil`, this method does nothing. @see [FICEntity drawingBlockForImage:withFormatName:] */ - (void)setEntryForEntityUUID:(NSString *)entityUUID sourceImageUUID:(NSString *)sourceImageUUID imageDrawingBlock:(FICEntityImageDrawingBlock)imageDrawingBlock; /** Returns a new image from the image entry data in the image table. @param entityUUID The UUID of the entity that uniquely identifies an image table entry. Must not be `nil`. @param sourceImageUUID The UUID of the source image that represents the actual image data stored in an image table entry. Must not be `nil`. @param preheatData A `BOOL` indicating whether or not the entry's image data should be preheated. See `&lt;[FICImageTableEntry preheat]&gt;` for more information. @return A new image created from the entry data stored in the image table or `nil` if something went wrong. @discussion The `UIImage` returned by this method is initialized by a `CGImageRef` backed directly by mapped file data, so no memory copy occurs. @note If either of the first two parameters to this method are `nil`, the return value is `nil`. @note If either the entity UUID or the source image UUID doesn't match the corresponding UUIDs in the entry data, then something has changed. The entry data is deleted for the provided entity UUID, and `nil` is returned. */ - (nullable UIImage *)newImageForEntityUUID:(NSString *)entityUUID sourceImageUUID:(NSString *)sourceImageUUID preheatData:(BOOL)preheatData; /** Deletes image entry data in the image table. @param entityUUID The UUID of the entity that uniquely identifies an image table entry. Must not be `nil`. @note If `entityUUID` is `nil`, this method does nothing. */ - (void)deleteEntryForEntityUUID:(NSString *)entityUUID; @end 这里直接从 Bang 哥那里搬张图过来 因为采用了 mmap 技术，所以每张图片的数据大小都是 page size align 的。 ImageTable 并不直接包含 Entry，而是在中间加了一层 Chunk。这个 Chunk 是每次运行时创建的，所以一个 Chunk 的大小、包含多少 Entry 你都可以随意设置。 mmap 的粒度是每一个 Chunk，这样既不会太大也不会太小，相当灵活。 基本流程 这里简单描述一下整个 FastImageCache 与 App 的工作流程。 App 进入某个列表，需要显示图片，所以调用了retrieveImageForEntity相关接口获取图片。 如果是第一次访问，此时还没有数据，则 FastImageCache 会要求 App 提供原始图片的数据。 拿到原始图片后，接下来需要寻找放到文件的哪个地方合适。如果文件不够放，则需要ftruncate扩展一下文件大小。此时会得到一个 ImageTableEntry。 根据 ImageFormat 的信息，创建一个 Bitmap，然后将图片绘制到 ImageTableEntry 其中的 bytes，其实就是写到文件中。 根据indexMap查询到图片 UUID 对应在文件哪个位置，创建对应的 ImageTableEntry。 将该位图数据读取出来，返回给 App 这里不想贴太多代码，自行查阅。 解码图片成位图的逻辑参考以下方法： -[FICImageTable setEntryForEntityUUID:sourceImageUUID:imageDrawingBlock:] 从内存映射文件中读取位图的逻辑参考以下方法： -[FICImageTable newImageForEntityUUID:sourceImageUUID:preheatData:] 注意点 &amp; 吐槽 ImageFormat 限制了图片的大小等信息，所以 FastImageCache 适用于那种有统一图像大小的场景，比如聊天头像、相册。 _sourceImageMap 没看到有什么作用，可能是个遗留代码。 ImageTable 中的_imageLength 和 Entry 中的 imageLength 是不相等的，前者是准确的数值，后者由于 page size align，算出来的不是准确的。虽然不影响使用。 ImageTable 里面用了一些奇奇怪怪的数据结果，看了好几遍代码才知道是什么意思。 比如_indexNumbers 缓存了 index 的 NSNumber 表示，用来**@synchronized**加锁，避免每次重新生成 NSNumber 变了。有 HashMap 锁表头那味了～ _inUseEntries 代表哪个 Entry 正在使用，发生缓存淘汰时，不能选这个 Entry。 在请求图片时，由于是异步的，ImageCache 中设置了一个很复杂的结构，我感觉这里是有 bug 的。 从图中可以看出，FormatKey 只对应一个 FormatName。但是 BlocksKey 里面有可能有多种 FormatName。 所以如果你的代码写成下面这样，同时图像加载失败了，你猜猜会有什么问题？ [[FICImageCache sharedImageCache] retrieveImageForEntity:photo withFormatName:FormatNameA completionBlock:^(id&lt;FICEntity&gt; entity, NSString *formatName, UIImage *image) { NSLog(@&quot;%@&quot;, formatName); }]; [[FICImageCache sharedImageCache] retrieveImageForEntity:photo withFormatName:FormatNameB completionBlock:^(id&lt;FICEntity&gt; entity, NSString *formatName, UIImage *image) { NSLog(@&quot;%@&quot;, formatName); }]; 框架有点复杂，如果你只是想简单提升一下滚动性能，可以在内存中做一下缓存即可。 在官方的 Demo 工程中，我给 FICDPhoto 加了几行代码，性能就飞上去了 🚀。 - (UIImage *)thumbnailImage { if (_thumbImage) { return _thumbImage; } UIImage *thumbnailImage = [UIImage imageWithContentsOfFile:[self _thumbnailFilePath]]; _thumbImage = thumbnailImage; return thumbnailImage; } 这里因为是缩略图，所以内存不会有太大消耗。不过列表滚动的场景，基本都是缩略图吧。 参考资料 iOS 图片加载速度极限优化—FastImageCache 解析 « bang’s blog ","link":"https://jayying007.github.io/post/FastImageCache框架分析/"},{"title":"AFNetworking源码分析","content":"https://github.com/AFNetworking/AFNetworking 简介 AFNetworking 这个网络框架，相信 iOS 开发都不陌生。如果你的项目是通过 Http 进行通信，那么这个框架可以帮你简化网络请求和响应的逻辑。 实际上它就是对系统 NSURLSession、NSURLSessionTask 这些逻辑做了封装，提供了更安全更易用的接口。 虽然老早就知道这个框架，但一直没有去看其源码实现。等到最近终于抽出时间看时，这个框架已经寿终正寝了。。。 虽然但是，大厂一般比较少用 Http 这种方式进行通信，而是直接基于 TCP 实现。所以 AFNetworking 的帮助就不大了。 这里推荐一个跨平台网络框架https://github.com/Tencent/mars，也是微信客户端使用的网络框架。 与原生的对比 这里简单写几个例子，演示用 AFNetworking 和不同 AFNetworking 代码的区别 {% tabs Get %} - (void)get { NSURL *url = [NSURL URLWithString:@&quot;https://httpbin.org/get?name=123&amp;password=456&quot;]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; [request setValue:@&quot;testValue&quot; forHTTPHeaderField:@&quot;Test-Header-Field&quot;]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response, NSError *_Nullable error) { if (error != nil) { NSLog(@&quot;出错了，%@&quot;, error); } else { NSString *result = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;, result); } }]; [task resume]; } - (void)af_get { [[AFHTTPSessionManager manager] GET:@&quot;https://httpbin.org/get&quot; parameters:@{ @&quot;name&quot; : @123, @&quot;password&quot; : @456 } headers:@{ @&quot;Test-Header-Field&quot; : @&quot;testValue&quot; } progress:nil success:^(NSURLSessionDataTask *_Nonnull task, id _Nullable responseObject) { NSLog(@&quot;%@&quot;, responseObject); } failure:^(NSURLSessionDataTask *_Nullable task, NSError *_Nonnull error) { NSLog(@&quot;出错了，%@&quot;, error); }]; } {% endtabs %} {% tabs Post %} - (void)post { NSURL *url = [NSURL URLWithString:@&quot;https://httpbin.org/post&quot;]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; [request setHTTPMethod:@&quot;POST&quot;]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response, NSError *_Nullable error) { if (error != nil) { NSLog(@&quot;出错了，%@&quot;, error); } else { NSString *result = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;, result); } }]; [task resume]; } - (void)af_post { [[AFHTTPSessionManager manager] POST:@&quot;https://httpbin.org/post&quot; parameters:nil headers:nil progress:nil success:^(NSURLSessionDataTask *_Nonnull task, id _Nullable responseObject) { NSLog(@&quot;%@&quot;, responseObject); } failure:^(NSURLSessionDataTask *_Nullable task, NSError *_Nonnull error) { NSLog(@&quot;出错了，%@&quot;, error); }]; } {% endtabs %} {% tabs Download %} - (void)download { NSURL *url = [NSURL URLWithString:@&quot;https://httpbin.org/image/jpeg&quot;]; NSURLRequest *request = [[NSURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration]; NSURLSession *session = [NSURLSession sessionWithConfiguration:config delegate:self delegateQueue:nil]; NSURLSessionDownloadTask *task = [session downloadTaskWithRequest:request]; [task resume]; } #pragma mark - NSURLSessionDownloadDelegate - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite { float rate = 1.f * totalBytesWritten / totalBytesExpectedToWrite; NSLog(@&quot;下载进度：%.2lf&quot;, rate); } - (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location { NSString *downloadPath = [location path]; NSLog(@&quot;已下载到路径：%@&quot;, downloadPath); UIImage *image = [UIImage imageWithContentsOfFile:downloadPath]; dispatch_async(dispatch_get_main_queue(), ^{ //self.imageView.image = image; }); } - (void)af_download { AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc] init]; manager.responseSerializer = [[AFImageResponseSerializer alloc] init]; [manager GET:@&quot;https://httpbin.org/image/jpeg&quot; parameters:nil headers:nil progress:^(NSProgress *_Nonnull downloadProgress) { NSLog(@&quot;下载进度：%.2lf&quot;, downloadProgress.fractionCompleted); } success:^(NSURLSessionDataTask *_Nonnull task, id _Nullable responseObject) { dispatch_async(dispatch_get_main_queue(), ^{ //self.imageView.image = responseObject; }); } failure:^(NSURLSessionDataTask *_Nullable task, NSError *_Nonnull error) { NSLog(@&quot;出错了，%@&quot;, error); }]; } {% endtabs %} 如果是下载图片，其实 AFNetworking 还扩展了 UIKit 组件的功能，可以写更少的代码。 {% tabs Upload %} - (void)upload { NSURL *url = [NSURL URLWithString:@&quot;https://httpbin.org/post&quot;]; NSMutableURLRequest *request = [[NSMutableURLRequest alloc] initWithURL:url cachePolicy:NSURLRequestUseProtocolCachePolicy timeoutInterval:30]; [request setHTTPMethod:@&quot;POST&quot;]; NSURLSession *session = [NSURLSession sharedSession]; UIImage *image = [UIImage imageNamed:@&quot;boss&quot;]; NSData *imgData = UIImagePNGRepresentation(image); NSURLSessionUploadTask *task = [session uploadTaskWithRequest:request fromData:imgData completionHandler:^(NSData *_Nullable data, NSURLResponse *_Nullable response, NSError *_Nullable error) { if (error != nil) { NSLog(@&quot;出错了，%@&quot;, error); } else { NSString *result = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; NSLog(@&quot;%@&quot;, result); } }]; [task resume]; } - (void)af_upload { [[AFHTTPSessionManager manager] POST:@&quot;https://httpbin.org/post&quot; parameters:nil headers:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; _Nonnull formData) { UIImage *image = [UIImage imageNamed:@&quot;boss&quot;]; NSData *imgData = UIImagePNGRepresentation(image); [formData appendPartWithFormData:imgData name:@&quot;imgData&quot;]; } progress:^(NSProgress *_Nonnull downloadProgress) { NSLog(@&quot;上传进度：%.2lf&quot;, downloadProgress.fractionCompleted); } success:^(NSURLSessionDataTask *_Nonnull task, id _Nullable responseObject) { NSLog(@&quot;%@&quot;, responseObject); } failure:^(NSURLSessionDataTask *_Nullable task, NSError *_Nonnull error) { NSLog(@&quot;出错了，%@&quot;, error); }]; } {% endtabs %} 对比代码看出，在 Apple 推出 NSURLSession 之后，AFNetworking 的作用相较于之前小了一些，但仍然还有用处。比如所有的网络请求都统一为 Block 的回调方式，而且带有 progess。 代码结构 对其源码的阅读可以分下面几个类别去看： 对 NSURLSession 及其上传/下载任务的管理 相关文件：AFURLSessionManager、AFHTTPSessionManager 这两个类可以说是框架的核心了，也是你使用 AFNetworking 99%的原因。 请求和响应的序列化 相关文件：AFURLRequestSerialization、AFURLResponseSerialization 比如你请求时带上的 queryString、HttpHeader、HttpBody，都可以通过 AFHTTPRequestSerializer 提供的更简单的接口实现。AFURLResponseSerialization 则可以将返回的 NSData 解析成你想要的数据类型。 安全相关 主要就是 AFSecurityPolicy 这个类，用于 SSL Pinning。 网络可达性 AFNetworkReachabilityManager 这个类框架本身并没有用到，是个相对独立的模块。 UIKit 的扩展 如支持了 UIButton、UIImageView 设置网络图片，有点像 SDWebImage。 源码分析 对 NSURLSession 及其上传/下载任务的管理 AFURLSessionManager 对 NSURLSession 做了封装，从某种意义上说，你不需要直接创建 or 调用 NSURLSession 的接口了，在 AFURLSessionManager 能找到常见的接口。 /** Creates and returns a manager for a session created with the specified configuration. This is the designated initializer. @param configuration The configuration used to create the managed session. @return A manager for a newly-created session. */ - (instancetype)initWithSessionConfiguration:(nullable NSURLSessionConfiguration *)configuration NS_DESIGNATED_INITIALIZER; /** Creates an `NSURLSessionDataTask` with the specified request. @param request The HTTP request for the request. @param uploadProgressBlock A block object to be executed when the upload progress is updated. Note this block is called on the session queue, not the main queue. @param downloadProgressBlock A block object to be executed when the download progress is updated. Note this block is called on the session queue, not the main queue. @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any. */ - (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request uploadProgress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock downloadProgress:(nullable void (^)(NSProgress *downloadProgress))downloadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; /** Creates an `NSURLSessionUploadTask` with the specified request for an HTTP body. @param request The HTTP request for the request. @param bodyData A data object containing the HTTP body to be uploaded. @param uploadProgressBlock A block object to be executed when the upload progress is updated. Note this block is called on the session queue, not the main queue. @param completionHandler A block object to be executed when the task finishes. This block has no return value and takes three arguments: the server response, the response object created by that serializer, and the error that occurred, if any. */ - (NSURLSessionUploadTask *)uploadTaskWithRequest:(NSURLRequest *)request fromData:(nullable NSData *)bodyData progress:(nullable void (^)(NSProgress *uploadProgress))uploadProgressBlock completionHandler:(nullable void (^)(NSURLResponse *response, id _Nullable responseObject, NSError * _Nullable error))completionHandler; AFURLSessionManager 对 NSURLSessionTask 事件的回调采用的是 Block+Notification 的方式。 /** Sets a block to be executed as the last message related to a specific task, as handled by the `NSURLSessionTaskDelegate` method `URLSession:task:didCompleteWithError:`. @param block A block object to be executed when a session task is completed. The block has no return value, and takes three arguments: the session, the task, and any error that occurred in the process of executing the task. */ - (void)setTaskDidCompleteBlock:(nullable void (^)(NSURLSession *session, NSURLSessionTask *task, NSError * _Nullable error))block; /** Sets a block to be executed when a download task has completed a download, as handled by the `NSURLSessionDownloadDelegate` method `URLSession:downloadTask:didFinishDownloadingToURL:`. @param block A block object to be executed when a download task has completed. The block returns the URL the download should be moved to, and takes three arguments: the session, the download task, and the temporary location of the downloaded file. If the file manager encounters an error while attempting to move the temporary file to the destination, an `AFURLSessionDownloadTaskDidFailToMoveFileNotification` will be posted, with the download task as its object, and the user info of the error. */ - (void)setDownloadTaskDidFinishDownloadingBlock:(nullable NSURL * _Nullable (^)(NSURLSession *session, NSURLSessionDownloadTask *downloadTask, NSURL *location))block; /** Posted when a task suspends its execution. */ FOUNDATION_EXPORT NSString * const AFNetworkingTaskDidSuspendNotification; AFURLSessionManager 持有了 NSURLSession，将 delegate 设置为自己，同时也存储了一个 AFURLSessionManagerTaskDelegate 数组，用于关联 NSURLSession 创建的 Task。 AFURLSessionManagerTaskDelegate 中维护了 progressBlock、completeBlock 等信息。 大致逻辑是，启动 NSURLSessionTask 时，NSURLSession 通过 NSURLSessionDelegate 通知到 AFURLSessionManager。然后 AFURLSessionManager 再找出对应的 AFURLSessionManagerTaskDelegate，将相关信息传递过去。 核心代码如下： - (void)URLSession:(__unused NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error { error = objc_getAssociatedObject(task, AuthenticationChallengeErrorKey) ?: error; __strong AFURLSessionManager *manager = self.manager; __block id responseObject = nil; NSMutableDictionary *userInfo = [NSMutableDictionary dictionary]; userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer; //Performance Improvement from #2672 NSData *data = nil; if (self.mutableData) { data = [self.mutableData copy]; //We no longer need the reference, so nil it out to gain back some memory. self.mutableData = nil; } //省略无关代码 if (error) { //略略略 } else { dispatch_async(url_session_manager_processing_queue(), ^{ NSError *serializationError = nil; responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError]; //省略无关代码 dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^{ if (self.completionHandler) { self.completionHandler(task.response, responseObject, serializationError); } dispatch_async(dispatch_get_main_queue(), ^{ [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo]; }); }); }); } } 请求和响应的序列化 AFHTTPRequestSerializer 用于简化 queryString、HttpHeader、HttpBody 等的设置。例如它会自动帮你加上 User-Agent、Accept-Language。 - (NSURLRequest *)requestBySerializingRequest:(NSURLRequest *)request withParameters:(id)parameters error:(NSError *__autoreleasing *)error { NSMutableURLRequest *mutableRequest = [request mutableCopy]; [self.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(id field, id value, BOOL * __unused stop) { if (![request valueForHTTPHeaderField:field]) { [mutableRequest setValue:value forHTTPHeaderField:field]; } }]; NSString *query = @&quot;&quot;; if (parameters) { if (self.queryStringSerialization) { //省略无关代码 } else { switch (self.queryStringSerializationStyle) { case AFHTTPRequestQueryStringDefaultStyle: query = AFQueryStringFromParameters(parameters); break; } } } if ([self.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) { if (query &amp;&amp; query.length &gt; 0) { mutableRequest.URL = [NSURL URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? @&quot;&amp;%@&quot; : @&quot;?%@&quot;, query]]; } } else { if (![mutableRequest valueForHTTPHeaderField:@&quot;Content-Type&quot;]) { [mutableRequest setValue:@&quot;application/x-www-form-urlencoded&quot; forHTTPHeaderField:@&quot;Content-Type&quot;]; } [mutableRequest setHTTPBody:[query dataUsingEncoding:self.stringEncoding]]; } return mutableRequest; } AFHTTPResponseSerializer 用于简化返回结果。NSURLSession 返回的是 NSData，利用 AFJSONResponseSerializer，可以将其转为 NSDictionary。利用 AFImageResponseSerializer，可以将其转为 UIImage。省下自己去写转换的代码。 - (id)responseObjectForResponse:(NSURLResponse *)response data:(NSData *)data error:(NSError *__autoreleasing *)error { if (![self validateResponse:(NSHTTPURLResponse *)response data:data error:error]) { if (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, NSURLErrorCannotDecodeContentData, AFURLResponseSerializationErrorDomain)) { return nil; } } //省略无关代码 id responseObject = [NSJSONSerialization JSONObjectWithData:data options:self.readingOptions error:&amp;serializationError]; //省略无关代码 return responseObject; } - (BOOL)validateResponse:(NSHTTPURLResponse *)response data:(NSData *)data error:(NSError * __autoreleasing *)error { BOOL responseIsValid = YES; NSError *validationError = nil; if ([response isKindOfClass:[NSHTTPURLResponse class]]) { if (self.acceptableContentTypes &amp;&amp; ![self.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp; !([response MIMEType] == nil &amp;&amp; [data length] == 0)) { //省略无关代码 responseIsValid = NO; } if (self.acceptableStatusCodes &amp;&amp; ![self.acceptableStatusCodes containsIndex:(NSUInteger)response.statusCode] &amp;&amp; [response URL]) { //省略无关代码 responseIsValid = NO; } } //省略无关代码 return responseIsValid; } 其中，AFImageResponseSerializer 可以配置对 UIImage 立即解码，直接绘制 bitmap。因为是在子线程，所以降低了主线程解码的压力。 UIKit 的扩展 这里以 UIImageView 支持设置网络图片为例，关键步骤都加了注释说明。 - (void)setImageWithURLRequest:(NSURLRequest *)urlRequest placeholderImage:(UIImage *)placeholderImage success:(void (^)(NSURLRequest *request, NSHTTPURLResponse *_Nullable response, UIImage *image))success failure:(void (^)(NSURLRequest *request, NSHTTPURLResponse *_Nullable response, NSError *error))failure { //1.是否已有相同的任务在下载 if ([self isActiveTaskURLEqualToURLRequest:urlRequest]) { return; } //2.取消之前的下载任务 [self cancelImageDownloadTask]; AFImageDownloader *downloader = [[self class] sharedImageDownloader]; //3.检查是否有缓存 id&lt;AFImageRequestCache&gt; imageCache = downloader.imageCache; UIImage *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:nil]; if (cachedImage) { self.image = cachedImage; [self clearActiveDownloadInformation]; return; } //4.没有缓存，开始下载图片 if (placeholderImage) { self.image = placeholderImage; } __weak __typeof(self) weakSelf = self; NSUUID *downloadID = [NSUUID UUID]; AFImageDownloadReceipt *receipt = [downloader downloadImageForURLRequest:urlRequest withReceiptID:downloadID success:^(NSURLRequest *_Nonnull request, NSHTTPURLResponse *_Nullable response, UIImage *_Nonnull responseObject) { __strong __typeof(weakSelf) strongSelf = weakSelf; //5.下载完成要检查downloadID是否跟当前最新的receipt匹配，有可能出现下载途中加入了新的下载任务or清除了下载任务 if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) { strongSelf.image = responseObject; [strongSelf clearActiveDownloadInformation]; } } failure:^(NSURLRequest *_Nonnull request, NSHTTPURLResponse *_Nullable response, NSError *_Nonnull error) { __strong __typeof(weakSelf) strongSelf = weakSelf; if ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) { if (failure) { failure(request, response, error); } [strongSelf clearActiveDownloadInformation]; } }]; self.af_activeImageDownloadReceipt = receipt; } 这其实就是一个标准的图片下载框架的实现逻辑。 下面简单看看 AFImageDownloader 的实现。 - (nullable AFImageDownloadReceipt *)downloadImageForURLRequest:(NSURLRequest *)request withReceiptID:(nonnull NSUUID *)receiptID success:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, UIImage *responseObject))success failure:(nullable void (^)(NSURLRequest *request, NSHTTPURLResponse * _Nullable response, NSError *error))failure { __block NSURLSessionDataTask *task = nil; dispatch_sync(self.synchronizationQueue, ^{ NSString *URLIdentifier = request.URL.absoluteString; if (URLIdentifier == nil) { if (failure) { NSError *error = [NSError errorWithDomain:NSURLErrorDomain code:NSURLErrorBadURL userInfo:nil]; dispatch_async(dispatch_get_main_queue(), ^{ failure(request, nil, error); }); } return; } // 1) Append the success and failure blocks to a pre-existing request if it already exists AFImageDownloaderMergedTask *existingMergedTask = self.mergedTasks[URLIdentifier]; if (existingMergedTask != nil) { AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure]; [existingMergedTask addResponseHandler:handler]; task = existingMergedTask.task; return; } // 2) Attempt to load the image from the image cache if the cache policy allows it switch (request.cachePolicy) { case NSURLRequestUseProtocolCachePolicy: case NSURLRequestReturnCacheDataElseLoad: case NSURLRequestReturnCacheDataDontLoad: { UIImage *cachedImage = [self.imageCache imageforRequest:request withAdditionalIdentifier:nil]; if (cachedImage != nil) { if (success) { dispatch_async(dispatch_get_main_queue(), ^{ success(request, nil, cachedImage); }); } return; } break; } default: break; } // 3) Create the request and set up authentication, validation and response serialization NSUUID *mergedTaskIdentifier = [NSUUID UUID]; NSURLSessionDataTask *createdTask; __weak __typeof__(self) weakSelf = self; createdTask = [self.sessionManager dataTaskWithRequest:request uploadProgress:nil downloadProgress:nil completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) { dispatch_async(self.responseQueue, ^{ __strong __typeof__(weakSelf) strongSelf = weakSelf; AFImageDownloaderMergedTask *mergedTask = [strongSelf safelyGetMergedTask:URLIdentifier]; if ([mergedTask.identifier isEqual:mergedTaskIdentifier]) { mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier]; if (error) { for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) { if (handler.failureBlock) { dispatch_async(dispatch_get_main_queue(), ^{ handler.failureBlock(request, (NSHTTPURLResponse *)response, error); }); } } } else { if ([strongSelf.imageCache shouldCacheImage:responseObject forRequest:request withAdditionalIdentifier:nil]) { [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil]; } for (AFImageDownloaderResponseHandler *handler in mergedTask.responseHandlers) { if (handler.successBlock) { dispatch_async(dispatch_get_main_queue(), ^{ handler.successBlock(request, (NSHTTPURLResponse *)response, responseObject); }); } } } } [strongSelf safelyDecrementActiveTaskCount]; [strongSelf safelyStartNextTaskIfNecessary]; }); }]; // 4) Store the response handler for use when the request completes AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure]; AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc] initWithURLIdentifier:URLIdentifier identifier:mergedTaskIdentifier task:createdTask]; [mergedTask addResponseHandler:handler]; self.mergedTasks[URLIdentifier] = mergedTask; // 5) Either start the request or enqueue it depending on the current active request count if ([self isActiveRequestCountBelowMaximumLimit]) { [self startMergedTask:mergedTask]; } else { [self enqueueMergedTask:mergedTask]; } task = mergedTask.task; }); if (task) { return [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task]; } else { return nil; } } 下载某个 URLRequest 时，会先在下载队列 mergedTasks 中检查是否已存在。 如果任务已存在，则给 AFImageDownloaderMergedTask 添加一个新的监听者即可（下载完成时会通知所有监听者），然后返回一个下载票据 AFImageDownloadReceipt。 如果不存在，则先查询本地缓存，有的话直接返回； 本地缓存不存在时，则需要创建一个新的 AFImageDownloaderMergedTask，然后加上监听者。这个过程通过 AFURLSessionManager 创建了一个 NSURLSessionDataTask。如果当前并发下载的次数还没达到上限的话，则直接启动 Task，否则就先进入队列等待。 参考资料 找的资料有点古老，一些还是讲的 NSURLConnection，可以直接跳过。 AFNetworking 2.0 AFNetworking2.0 源码解析 « bang’s blog ","link":"https://jayying007.github.io/post/AFNetworking源码分析/"},{"title":"FBRetainCycleDetector源码分析","content":"https://github.com/facebook/FBRetainCycleDetector 内存管理概念 对于程序中的内存对象管理，一般分为手动管理、引用计数管理、垃圾回收。 手动管理：例如 C 语言，malloc 后不需要时，需要 free，不然就会内存泄露。 引用计数：Objective-C 的内存管理方式，稍有不慎就会造成循环引用，这也是FBRetainCycleDetector要解决的问题。 垃圾回收：Java 的内存管理方式，之前写过文章简述 - 垃圾回收算法_Mrzhuang007 的博客-CSDN 博客 循环引用的检测原理 首先需要知道程序创建了哪些 OC 对象，这个可以通过 hook alloc 或者 allocWithZone 去监测； 接下来要知道每个对象强引用了哪些对象； 寻找是否有引用回路； 最后需要去重，比如 A-&gt;B-&gt;C-&gt;A 和 B-&gt;C-&gt;A-&gt;B 属于同一条链路。 可以看出，检测循环引用，相当于在一个有向图中找到环。 这就很简单了，遍历每个对象做一下 dfs，就可以知道每个对象是否位于环中，以及属于哪个环。 FBRetainCycleDetector 的实现 对象检测 FBRetainCycleDetector实际上没有 hook alloc 之类的方法，要检测是否存在循环引用，需要我们自己主动添加对象，通过addCandidate:方法。 即只对这些对象做 dfs，毕竟实际项目中对象实在太多了，检测起来内存和性能都是问题。 FBRetainCycleDetector的方法只有三个： 构造函数可配置哪些边可以忽略，毕竟有些循环引用是故意的，会在之后自行打断； 添加 dfs 搜索的初始对象； 返回搜索结果，数组代表环的数量，数组里的元素为集合，代表每个环的组成。 /** FBRetainCycleDetector The main class responsible for detecting retain cycles. Be cautious, the class is NOT thread safe. The process of detecting retain cycles is relatively slow and consumes a lot of CPU. */ @interface FBRetainCycleDetector : NSObject /** Designated initializer @param configuration Configuration for detector. Can include specific filters and options. @see FBRetainCycleDetectorConfiguration */ - (nonnull instancetype)initWithConfiguration:(nonnull FBObjectGraphConfiguration *)configuration NS_DESIGNATED_INITIALIZER; /** Adds candidate you are interested in getting retain cycles from. @param candidate Any Objective-C object you want to verify for cycles. */ - (void)addCandidate:(nonnull id)candidate; /** Searches for all retain cycles for all candidates the detector has been provided with. @return NSSet with retain cycles. An element of this array will be an array representing retain cycle. That array will hold elements of type FBObjectiveCGraphElement. @discussion For given candidate, the detector will go through all object graph rooted in this candidate and return ALL retain cycles that this candidate references. It will also take care of removing duplicates. It will not look for cycles longer than 10 elements. If you want to look for longer ones use findRetainCyclesWithMaxCycleLenght: */ - (nonnull NSSet&lt;NSArray&lt;FBObjectiveCGraphElement *&gt; *&gt; *)findRetainCycles; @end 对象结构与引用描述 对于有向图上的所有节点，都是用FBObjectiveCGraphElement来描述。 /** Base Graph Element representation. It carries some data about the object and should be overridden in subclass to provide references that subclass holds strongly (different for blocks, objects, other specializations). The Graph Element itself can only provide references from FBAssociationManager. */ @interface FBObjectiveCGraphElement : NSObject /** Designated initializer. @param object Object this Graph Element will represent. @param configuration Provides detector's configuration that contains filters and options @param namePath Description of how the object was retrieved from it's parent. Check namePath property. */ - (nonnull instancetype)initWithObject:(nullable id)object configuration:(nonnull FBObjectGraphConfiguration *)configuration namePath:(nullable NSArray&lt;NSString *&gt; *)namePath; /** Name path that describes how this object was retrieved from its parent object by names (for example ivar names, struct references). For more check FBObjectReference protocol. */ @property (nonatomic, copy, readonly, nullable) NSArray&lt;NSString *&gt; *namePath; @property (nonatomic, weak, nullable) id object; @property (nonatomic, readonly, nonnull) FBObjectGraphConfiguration *configuration; /** Main accessor to all objects that the given object is retaining. Thread unsafe. @return NSSet of all objects this object is retaining. */ - (nullable NSSet *)allRetainedObjects; @end 结合 ObjC 的特性，可以扩展出以下类型： 之所以有不同的派生类，主要是获取强引用对象的方法allRetainedObjects有所不同 FBObjectiveCGraphElement：获取 associate 绑定的对象； FBObjectiveCBlock：原有基础上，利用 Block 的结构体，计算出强引用的对象； FBObjectiveCObject：原有基础上，获取 Ivars，如果为集合对象，则获取其 keys 和 values； FBObjectiveCNSCFTimer：原有基础上，获取 NSTimer 中的 target 和 userInfo； Ivars 可以利用 ObjC Runtime 获取，利用 IvarsLayout 可以知道是弱引用还是强引用。对于 IvarsLayout 的说明可以参考这篇文章 对于结构体内部变量的获取则稍微复杂一些，需要考虑结构体对齐问题，然后利用 typeEncoding 获得 OC 对象。 Block 则创建一些虚拟的对象，然后调用 Block 的 dispose 方法，谁调用了 release 方法就可以知道哪个是真正的 OC 强引用对象。 Ivars、结构体、Block 强引用对象的方法还挺有意思的，建议自行阅读源码，感受其奥秘。 循环引用的检测 上文也说了，检测用的是 DFS，不过这里并没有用递归，而是利用循环去模拟桟的运行。代码如下： - (NSSet&lt;NSArray&lt;FBObjectiveCGraphElement *&gt; *&gt; *)_findRetainCyclesInObject:(FBObjectiveCGraphElement *)graphElement stackDepth:(NSUInteger)stackDepth { NSMutableSet&lt;NSArray&lt;FBObjectiveCGraphElement *&gt; *&gt; *retainCycles = [NSMutableSet new]; FBNodeEnumerator *wrappedObject = [[FBNodeEnumerator alloc] initWithObject:graphElement]; // We will be doing DFS over graph of objects // Stack will keep current path in the graph NSMutableArray&lt;FBNodeEnumerator *&gt; *stack = [NSMutableArray new]; // To make the search non-linear we will also keep // a set of previously visited nodes. NSMutableSet&lt;FBNodeEnumerator *&gt; *objectsOnPath = [NSMutableSet new]; // Let's start with the root [stack addObject:wrappedObject]; while ([stack count] &gt; 0) { // Take topmost node in stack and mark it as visited FBNodeEnumerator *top = [stack lastObject]; [objectsOnPath addObject:top]; // Take next adjecent node to that child. Wrapper object can // persist iteration state. If we see that node again, it will // give us new adjacent node unless it runs out of them FBNodeEnumerator *firstAdjacent = [top nextObject]; if (firstAdjacent) { // Current node still has some adjacent not-visited nodes BOOL shouldPushToStack = NO; // Check if child was already seen in that path if ([objectsOnPath containsObject:firstAdjacent]) { // We have caught a retain cycle NSUInteger index = [stack indexOfObject:firstAdjacent]; NSInteger length = [stack count] - index; NSRange cycleRange = NSMakeRange(index, length); NSMutableArray&lt;FBNodeEnumerator *&gt; *cycle = [[stack subarrayWithRange:cycleRange] mutableCopy]; [cycle replaceObjectAtIndex:0 withObject:firstAdjacent]; [retainCycles addObject:[self _unwrapCycle:cycle]]; } else { // Node is clear to check, add it to stack and continue shouldPushToStack = YES; } if (shouldPushToStack &amp;&amp; [stack count] &lt; stackDepth) { [stack addObject:firstAdjacent]; } } else { // Node has no more adjacent nodes, it itself is done, move on [stack removeLastObject]; [objectsOnPath removeObject:top]; } } return retainCycles; } 为了代码的易读性，这里删了一些代码。 其实这里还做了 dfs 的剪枝优化，跳过了一些不必要的遍历路径，代码如下 // We don't want to retraverse the same subtree if (![objectsOnPath containsObject:top]) { if ([_objectSet containsObject:@([top.object objectAddress])]) { [stack removeLastObject]; continue; } // Add the object address to the set as an NSNumber to avoid // unnecessarily retaining the object [_objectSet addObject:@([top.object objectAddress])]; } 设想下面的场景 dfs 通过路径 A-&gt;B-&gt;D-&gt;E-&gt;F-&gt;D，已经发现了 D、E、F 之间的循环引用。而且按照 dfs 的特性，D、E、F 所有关联的路径都已经遍历完了。 后面当 dfs 来到 A-&gt;C-&gt;E 时，其实就没必要再往下检测了，因为 E 所有路径都检查过了。 补充 对于最后检测出来的环，选择其中对象地址最小的作为环的头节点。然后在根据类名进行字符串排序，找到一个字典序最小的。 最后这两个感觉可有可无，没发现有什么场景需要用到。 查看 Git 的提交记录，可以发现是最初的去重版本。后面引入剪枝后，就没作用了，只是代码还没删。。 ","link":"https://jayying007.github.io/post/FBRetainCycleDetector源码分析/"},{"title":"Mach-O文件的构建、解析与运行","content":" 省流：如果你还没有看过《程序员的自我修养》，那建议还是先去看完这本书吧。 简介 类似于 Window 的 PE 文件、Linux 的 ELF 文件，OS X 上所有的 App、Framework、Libiary、Command-Line Tool 都可以称为 Mach-O 文件。 对这些 Mach-O 文件的进一步描述，可以参考The Products—Types of Mach-O Files You Can Build 一个 Mach-O 文件由三部分组成：Header、Load Commands、Data。 Header：包含该文件的目标架构等信息； Load Commands：描述了该文件的基本结构（比如符号表在哪个地方，Segment 要加到虚拟内存地址的哪个地方）； Data：裸的数据，具体每个 Byte 代表啥就看 Load Commands 中的定义了。 一个 Mach-O 只包含一种架构的代码和数据，包含多个的被称为 universal binary。这种情况下，文件开头为一个fat_header结构体，跟随一个fat_arch结构体数组，根据这个fat_arch的信息，就能快速找到适合当前机器执行的代码和数据的位置。 程序运行过程浅析 Mach-O 文件有可能是一个可执行文件类型，这里简单说明一下通过命令行或双击启动一个可执行文件的过程。 再说一次，想获取这部分更完整的知识，去看《程序员的自我修养》。 当运行一个程序时，内核为该程序创建对应的进程，并将其载入进程空间中，同时也会把动态链接器（通常是/usr/lib/dyld）载入进程空间中。随后把控制器交给动态链接器，即跳转到动态链接器指定的入口地址。 这个过程涉及两个系统调用，fork和execve。fork创建了进程，execve将程序载入进程空间并执行。载入的 Mach-O 文件中，会有一条 load command 指示从哪里加载动态链接器。 动态链接器会查找程序依赖的所有动态库（这部分信息也在 load command 中），然后递归将它们也加进来。 随后动态链接器会做必要的符号绑定，然后调用程序的入口点。这个入口点函数是静态链接时添加的，它会做一些 C++静态对象初始化、ObjC 运行时之类的操作，最后会调用 main 函数。 小结 App 启动过程其实之前也写过文章分享，传送门 iOS App 的启动过程（流程篇） 或者看下苹果文档：Forking and Executing the Process、Finding Imported Symbols 下面稍微介绍一下符号绑定。 符号绑定 讲解符合绑定之前，先简单说明一下模块（module）的含义，模块是由数据和代码构成的最小单元，可以独立跟其他单元链接。例如编译文件 main.c、thing.c、foo.c，产生了 main.o、thing.o、foo.o，这里就是三个模块。不过在编译 App 时，静态链接器会把它们合并为同一模块。 同一模块内，由于知道函数、数据的地址，所有模块内的符号引用都可以在静态阶段确定下来。但是程序也会存在引用 open、printf 这类系统库中的符号，属于跨模块符号引用。 一个模块（源程序）引用了另一个模块（动态库）的数据或函数，需要等另一个模块加载到进程空间后，才能确定该模块函数和数据的具体地址，然后再做引用符号地址的修正，或者叫符号绑定。 符号绑定的方式通常有以下几种： lazy-binding，虽然程序运行时就把共享库加到进程空间中，但直到第一次引用符号时，动态链接器才去做绑定。 load-time binding，顾名思义，程序运行时就进行绑定。默认情况下，动态链接器执行 lazy-binding 的策略。在 ld 阶段，通过添加参数-bind_at_load即可强制运行时绑定。 prebinding，少用，不多做说明。 不过符号绑定没有这么简单，仔细一想，你知道了 open、printf 等函数的地址，但是你无法将这些信息填充到源程序的代码段中，因为代码段的权限是只读和可执行，不能写。 似乎陷入了僵局，动态库的函数地址要运行时才能确定，而修改代码段只能在静态链接阶段，一旦载入内存就无法修改。 不过退一万步讲，即使代码段可写，也会有其他问题。除了源程序引用动态库，也会有动态库引用另一个动态库的情况，也就是说，动态库里面也有引用符号需要修正。问题就在这里，你的程序修正了动态库里面的符号引用地址，但是动态库是所有进程共享的呀。有可能其他进程也依赖这个动态库，而它对应的符号地址不见得跟你的一样，这样搞其他进程就崩溃了。那你只能每个进程都搞一份自己的，不过这样就失去了动态库节省空间的一大优势了。 不过办法总比困难多，代码段不可写，但是数据段可写呀，于是就有了曲线救国的方式。动态库的函数地址运行时确定后，把地址写到__DATA的某个地方。由于__TEXT和__DATA的相对位置是固定的，所以代码上可以利用当前 PC+偏移量得到地址存放的位置，然后再访问地址。这种方式又叫间接符号引用。 fishhook利用这个特性实现了 Hook C 函数。 PS：本来想写一篇源码分析文章的，但源码其实就两百来行，知道 Mach-O 和动态链接的特性后也不难理解，于是放弃了。 庖丁解牛 前面已经讲了 Mach-O 文件执行的一些细节，接下来就亲自动手，逐个 Byte 分析 Mach-O 文件的奥秘。中间会穿插各种 🧑‍💻Coding，用于验证。 工欲善其事，必先利其器 查看一个 Mach-O 文件包含什么信息，有很多工具可以使用。 lipo：分析体系结构 file：显示文件类型 otool：查看 Mach-O 文件具体的 Segment、Section 数据 pagestuff：按页查看文件信息 nm：查看符号表 libtool：可将多个中间文件合并为静态库 a 💡 上面的都是命令行工具，其实还有一个常用的可视化工具 MachOView 另外再补一下我的电脑配置 emmm，当时 M1 Max 刚出时买的，等了快一个月才到货... 🧑‍💻Coding 环节 创建一个文件file_b.c，内容如下 int base = 0xfff0; int getAddress(int base, int offset) { return base + offset; } 然后编译 //单独编译，不链接 clang -c file_b.c -o file_b.o Header Mach-O 文件开头是一个mach_header结构体。代码位于 mach-o/loader.h，其在 32 位和 64 位机器下结构稍有不同。 /* * The 32-bit mach header appears at the very beginning of the object file for * 32-bit architectures. */ struct mach_header { uint32_t magic; /* mach magic number identifier */ int32_t cputype; /* cpu specifier */ int32_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ }; struct mach_header_64 { uint32_t magic; /* mach magic number identifier */ int32_t cputype; /* cpu specifier */ int32_t cpusubtype; /* machine specifier */ uint32_t filetype; /* type of file */ uint32_t ncmds; /* number of load commands */ uint32_t sizeofcmds; /* the size of all the load commands */ uint32_t flags; /* flags */ uint32_t reserved; /* reserved */ }; magic 表示当前 Mach-O 文件可运行于 32 位还是 64 位机器，以及机器的端序。 /* Constant for the magic field of the mach_header (32-bit architectures) */ #define MH_MAGIC 0xfeedface /* the mach magic number */ #define MH_CIGAM 0xcefaedfe /* NXSwapInt(MH_MAGIC) */ /* Constant for the magic field of the mach_header_64 (64-bit architectures) */ #define MH_MAGIC_64 0xfeedfacf /* the 64-bit mach magic number */ #define MH_CIGAM_64 0xcffaedfe /* NXSwapInt(MH_MAGIC_64) */ cputype、cpusubtype 表示机器架构，如 CPU_TYPE_ARM64、CPU_TYPE_X86_64。更多定义可以查看 mach/machine.h filetype 表示 Mach-O 文件的类型，常见的有：中间对象文件（MH_OBJECT）、可执行二进制（MH_EXECUTE）、VM 共享库文件（MH_FVMLIB）、Crash 产生的 Core 文件（MH_CORE）、动态共享库（MH_DYLIB）、动态链接器（MH_DYLINKER）、静态链接文件（MH_DYLIB_STUB）、符号文件和调试信息（MH_DSYM） ncmds 和 sizeofcmds 代表有多少 load command 以及所占大小 flags 是一些标记字段，具体含义可参考 loader.h 中的说明。 🧑‍💻Coding 环节 我们可以用命令行工具打印一下 otool -v -h file_b.o 结果如下 Mach header magic cputype cpusubtype caps filetype ncmds sizeofcmds flags MH_MAGIC_64 ARM64 ALL 0x00 OBJECT 4 440 SUBSECTIONS_VIA_SYMBOLS 直接用代码验证 为了便于后续代码编写，这里加几个别名和宏定义，新出现的也按同样规则处理 #ifdef __LP64__ typedef struct mach_header_64 mach_header_t; typedef struct segment_command_64 segment_command_t; typedef struct section_64 section_t; typedef struct nlist_64 nlist_t; #define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT_64 #else typedef struct mach_header mach_header_t; typedef struct segment_command segment_command_t; typedef struct section section_t; typedef struct nlist nlist_t; #define LC_SEGMENT_ARCH_DEPENDENT LC_SEGMENT #endif #ifndef SEG_DATA_CONST #define SEG_DATA_CONST &quot;__DATA_CONST&quot; #endif typedef struct load_command load_command_t; typedef struct dylib_command dylib_command_t; typedef struct dylinker_command dylinker_command_t; typedef struct symtab_command symtab_command_t; typedef struct dysymtab_command dysymtab_command_t; void *getFilePointer(const char *filePath) { int fd = open(filePath, O_RDONLY, S_IRUSR); struct stat st = {}; fstat(fd, &amp;st); uint64_t fileSize = (uint64_t)st.st_size; void *ptr = mmap(NULL, fileSize, PROT_READ, MAP_SHARED, fd, 0); return ptr; } void startReadMachO(const char *filePath) { void *filePtr = getFilePointer(filePath); void *curPtr = filePtr; mach_header_t *header = (mach_header_t *)curPtr; printf(&quot;magic: %x\\n&quot;, header-&gt;magic); printf(&quot;cputype: %u\\n&quot;, header-&gt;cputype); printf(&quot;cpusubtype: %u\\n&quot;, header-&gt;cpusubtype); printf(&quot;filetype: %u\\n&quot;, header-&gt;filetype); printf(&quot;ncmds: %u\\n&quot;, header-&gt;ncmds); printf(&quot;sizeofcmds: %u\\n&quot;, header-&gt;sizeofcmds); printf(&quot;flags: %u\\n&quot;, header-&gt;flags); } 传入 file_b.o 的路径，得到以下输出，数据吻合 magic: feedfacf cputype: 16777228 cpusubtype: 0 filetype: 1 ncmds: 4 sizeofcmds: 440 flags: 8192 Load Commands 下一步来到 load command，从 mach_header 那里我们已经知道了 load commands 的总体大小。 load command 有很多种，但是所有 load command 结构体的前两个属性是一样的，类似于面向对象中的基类。 struct load_command { uint32_t cmd; /* type of load command */ uint32_t cmdsize; /* total size of command in bytes */ }; cmd 代表了 load command 的类型，cmdsize 代表具体 load command 的结构体大小 + 额外数据大小。具体的 load command 结构可在 loader.h 中查看 在我们的file_b.o中，共有 4 个 load commands，分别为 LC_BUILD_VERSION、LC_SEGMENT_64、LC_SYMTAB、LC_DYSYMTAB，第一个不太重要，直接忽略。 LC_SEGMENT_64 对应结构体segment_command_64，指定了 Mach-O 文件某个段的信息，段是会被载入进程空间的，结构体中同时还说明了载入的虚拟地址位置。 再次祭出这张图 Data 包含一个或多个 segment 的数据，一个 segment 有 0 个或多个 section，每个 section 包含 code 或者 data。 每个 section 都有编号，从 1 开始，且跨多个 segment。比如第一个 segment 有 section1 section2 section3，第二个 segment 有 section4 section5... section 对应结构体section_64，跟在segment_command_64之后。 /* * The 64-bit segment load command indicates that a part of this file is to be * mapped into a 64-bit task's address space. If the 64-bit segment has * sections then section_64 structures directly follow the 64-bit segment * command and their size is reflected in cmdsize. */ struct segment_command_64 { /* for 64-bit architectures */ uint32_t cmd; /* LC_SEGMENT_64 */ uint32_t cmdsize; /* includes sizeof section_64 structs */ char segname[16]; /* segment name */ uint64_t vmaddr; /* memory address of this segment */ uint64_t vmsize; /* memory size of this segment */ uint64_t fileoff; /* file offset of this segment */ uint64_t filesize; /* amount to map from the file */ int32_t maxprot; /* maximum VM protection */ int32_t initprot; /* initial VM protection */ uint32_t nsects; /* number of sections in segment */ uint32_t flags; /* flags */ }; struct section_64 { /* for 64-bit architectures */ char sectname[16]; /* name of this section */ char segname[16]; /* segment this section goes in */ uint64_t addr; /* memory address of this section */ uint64_t size; /* size in bytes of this section */ uint32_t offset; /* file offset of this section */ uint32_t align; /* section alignment (power of 2) */ uint32_t reloff; /* file offset of relocation entries */ uint32_t nreloc; /* number of relocation entries */ uint32_t flags; /* flags (section type and attributes)*/ uint32_t reserved1; /* reserved (for offset or index) */ uint32_t reserved2; /* reserved (for count or sizeof) */ uint32_t reserved3; /* reserved */ }; segment 和 section 都有名字，一般来说，segment 用双下划线+大写字母，section 用双下划线+小写字母。 可执行文件的 segment 通常有以下六种类型： __PAGEZERO，可执行文件中的第一个 segment，在虚拟内存中的地址为零，size 代表虚拟内存中一页的大小。 __TEXT，包含可执行的代码、只读数据。因为不可写，所以可以当做共享内存，其他进程也能获取。例如运行同一个程序多次、Framework 的代码、共享库。 __DATA，可读写的数据。因此每个进程都要单独拷贝一份 Framework、共享库的数据，拷贝采用 copy-on-write 策略。 __OBJC，用于支持 Objective-C Runtime 的相关数据 __IMPORT，包含一些未被定义的符号，只为 IA-32 架构使用，现在可以忽略。 __LINKEDIT，包含符号表、字符串表、重定位表等数据。 在用户最终链接成的 Mach-O 文件中，最后一个 segment 为__LINKEDIT。 🧑‍💻Coding 环节 curPtr = curPtr + sizeof(mach_header_t); load_command_t *command; for (int i = 0; i &lt; header-&gt;ncmds; i++, curPtr += command-&gt;cmdsize) { command = (load_command_t *)curPtr; if (command-&gt;cmd == LC_SEGMENT_ARCH_DEPENDENT) { segment_command_t *segment_command = (segment_command_t *)command; printf(&quot;segment: %s \\n&quot;, segment_command-&gt;segname); printf(&quot;sections:\\n&quot;); section_t *sections = (section_t *)(curPtr + sizeof(segment_command_t)); for (int j = 0; j &lt; segment_command-&gt;nsects; j++) { printf(&quot;%s %s \\n&quot;, sections[j].segname, sections[j].sectname); printf(&quot;flags: 0x%x \\n&quot;, sections[j].flags); } printf(&quot;\\n\\n&quot;); } } 输出结果如下 segment: sections: __TEXT __text flags: 0x80000400 __DATA __data flags: 0x0 __LD __compact_unwind__LD flags: 0x2000000 打印之后你会发现，只有一个 segment，而且还没有名字。这是为了中间目标文件的紧凑性故意处理的，这个 segment 里面包含了各种各样的 section，属于不同 segment，会在静态链接时放置到合理的位置上。 这里有三个 section。 __compact_unwind__LD，这是一个 debug 用的，可以忽略。 __text，包含可执行的机器指令。 __data，包含有初始化值的变量。在file_b.c中，我们只有int base = 0xfff0这么个初始化变量。 可以打印出来验证 if (strcmp(sections[j].sectname, SECT_DATA) == 0) { int *value = (int *)(filePtr + sections[j].offset); printf(&quot;%x \\n&quot;, *value); } LC_SYMTAB 对应结构体symtab_command，描述了符号表的位置和大小。所谓的符号表，是由nlist_64构成的结构体数组。 /* * The symtab_command contains the offsets and sizes of the link-edit 4.3BSD * &quot;stab&quot; style symbol table information as described in the header files * &lt;nlist.h&gt; and &lt;stab.h&gt;. */ struct symtab_command { uint32_t cmd; /* LC_SYMTAB */ uint32_t cmdsize; /* sizeof(struct symtab_command) */ uint32_t symoff; /* symbol table offset */ uint32_t nsyms; /* number of symbol table entries */ uint32_t stroff; /* string table offset */ uint32_t strsize; /* string table size in bytes */ }; /* * This is the symbol table entry structure for 64-bit architectures. */ struct nlist_64 { union { uint32_t n_strx; /* index into the string table */ } n_un; uint8_t n_type; /* type flag, see below */ uint8_t n_sect; /* section number or NO_SECT */ uint16_t n_desc; /* see &lt;mach-o/stab.h&gt; */ uint64_t n_value; /* value of this symbol (or stab offset) */ }; 🧑‍💻Coding 环节 if (command-&gt;cmd == LC_SYMTAB) { symtab_command_t *symtab_command = (symtab_command_t *)command; nlist_t *nlists = (nlist_t *)(filePtr + symtab_command-&gt;symoff); uint32_t strOffset = symtab_command-&gt;stroff; for (int j = 0; j &lt; symtab_command-&gt;nsyms; j++) { nlist_t nlist = nlists[j]; printf(&quot;symbol: %s type:%u sect:%u desc:%u value:%llu \\n&quot;, (char *)(filePtr + strOffset + nlist.n_un.n_strx), nlist.n_type, nlist.n_sect, nlist.n_desc, nlist.n_value); } } 输出结果中，可以看到符号_base 和_getAddress symbol: ltmp0 type:14 sect:1 desc:0 value:0 symbol: ltmp1 type:14 sect:2 desc:0 value:32 symbol: ltmp2 type:14 sect:3 desc:0 value:40 symbol: _base type:15 sect:2 desc:0 value:32 symbol: _getAddress type:15 sect:1 desc:0 value:0 根据 value 可以知道_base 是一个全局符号 #define N_GSYM 0x20 /* global symbol */ LC_DYSYMTAB 对应结构体dysymtab_command，描述了用于动态链接部分的符号表。 🧑‍💻Coding 环节 if (command-&gt;cmd == LC_DYSYMTAB) { dysymtab_command_t *dysymtab_command = (dysymtab_command_t *)command; printf(&quot;local: %u extdef: %u undef: %u \\n&quot;, dysymtab_command-&gt;nlocalsym, dysymtab_command-&gt;nextdefsym, dysymtab_command-&gt;nundefsym); } 这里有三个本地符号，两个对外符号，符合预期 local: 3 extdef: 2 undef: 0 🧑‍💻Coding 环节 file_b.o 我们已经扒得差不多了，是时候写个新的代码了，就叫 file_a.c #include &quot;file_b.h&quot; int printf(const char *, ...); int main(int argc, char *argv[]) { int offset = 0x10; int address = getAddress(base, offset); printf(&quot;address is %x&quot;, address); return 0; } file_a.c 需要用到 base 和 getAddress，所以要把这两个信息提供出来 extern int base; int getAddress(int base, int offset); 然后编译 //单独编译，不链接 clang -c file_a.c -o file_a.o 接下来的代码跟之前的一样，我们直接看输出 magic: feedfacf cputype: 16777228 cpusubtype: 0 filetype: 1 ncmds: 4 sizeofcmds: 440 flags: 8192 segment: sections: __TEXT __text flags: 0x80000400 __TEXT __cstring flags: 0x2 __LD __compact_unwind__LD flags: 0x2000000 symbol: ltmp0 type:14 sect:1 desc:0 value:0 symbol: l_.str type:14 sect:2 desc:0 value:108 symbol: ltmp1 type:14 sect:2 desc:0 value:108 symbol: ltmp2 type:14 sect:3 desc:0 value:128 symbol: _main type:15 sect:1 desc:0 value:0 symbol: _base type:1 sect:0 desc:0 value:0 symbol: _getAddress type:1 sect:0 desc:0 value:0 symbol: _printf type:1 sect:0 desc:0 value:0 local: 4 extdef: 1 undef: 3 这里多了一个前面没有的 section __cstring，里面包含 C 字符串，即&quot;address is %x&quot;，可以验证下 if (sections[j].flags == S_CSTRING_LITERALS) { printf(&quot;%s \\n&quot;, (char *)(filePtr + sections[j].offset)); } 然后也没有多余的可分析了，把两个 Mach-O 链接成可执行文件看看 //链接成可执行文件target.o ld -lSystem -syslibroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk -o target.o file_a.o file_b.o //执行一下target.o，可正常运行 ./target.o 链接成可执行文件后，又多了好几个 load commands，这里同样只挑几个有意思的讲讲 LC_LOAD_DYLINKER 对应结构体dylinker_command，指示了动态链接器的路径。 每个动态链接的可执行文件都包含该 command，该 command 包含指明了内核在启动进程时，从哪个地方启动 dyld。如果这个文件就是动态链接器本身，则通过 LC_ID_DYLINKER 指明。 if (command-&gt;cmd == LC_LOAD_DYLINKER) { dylinker_command_t *dylinker_command = (dylinker_command_t *)command; uint32_t length = dylinker_command-&gt;cmdsize - sizeof(dylinker_command_t); uint32_t offset = dylinker_command-&gt;name.offset; printf(&quot;length: %u dylinker: %s \\n\\n&quot;, length, (char *)(curPtr + offset)); } 输出 length: 20 dylinker: /usr/lib/dyld LC_LOAD_DYLIB 对应结构体dylib_command，指示了依赖的动态库。前面提过，动态链接器会把所有依赖的库加到进程中，如果动态库依赖其他动态库，则递归进行加载，然后再做符号绑定。 if (command-&gt;cmd == LC_LOAD_DYLIB) { dylib_command_t *dylib_command = (dylib_command_t *)command; uint32_t length = dylib_command-&gt;cmdsize - sizeof(dylib_command_t); //得到dylib.name的长度 uint32_t offset = dylib_command-&gt;dylib.name.offset; printf(&quot;length:%u dylib: %s \\n\\n&quot;, length, (char *)(curPtr + offset)); } 输出 length:32 dylib: /usr/lib/libSystem.B.dylib LC_MAIN 对应结构体entry_point_command，即 main 函数的地址 LC_DATA_IN_CODE 对应结构体linkedit_data_command，在代码段的数据，即只读数据。 /* * The linkedit_data_command contains the offsets and sizes of a blob * of data in the __LINKEDIT segment. */ struct linkedit_data_command { uint32_t cmd; /* LC_CODE_SIGNATURE, LC_SEGMENT_SPLIT_INFO, LC_FUNCTION_STARTS, LC_DATA_IN_CODE, LC_DYLIB_CODE_SIGN_DRS, LC_LINKER_OPTIMIZATION_HINT, LC_DYLD_EXPORTS_TRIE, or LC_DYLD_CHAINED_FIXUPS. */ uint32_t cmdsize; /* sizeof(struct linkedit_data_command) */ uint32_t dataoff; /* file offset of data in __LINKEDIT segment */ uint32_t datasize; /* file size of data in __LINKEDIT segment */ }; linkedit_data_command结构体被很多 load command 共用。 Data 在最终的 target.o 中，多了一个 segment,__DATA_CONST，里面有一个 section,__got。这其实就是我们符号绑定时提到的间接符号引用，因为我们这里引用了 printf 这个动态库符号。 关于如何判断这个 section 每个位置代表哪个间接符号引用的地址，可以参考fishhook中的实现。 参考资料 除了上面贴过的链接外 https://github.com/aidansteele/osx-abi-macho-file-format-reference Mach-O Programming Topics Apple 操作系统可执行文件 Mach-O 《iOS 应用安全与逆向之道》 动态修改 C 语言函数的实现 - 面向信仰编程 ","link":"https://jayying007.github.io/post/Mach-O文件的构建、解析与运行/"},{"title":"一个简单的天气App","content":"这两天看了一个 iOS 开发教程，虽然是 iOS7 那会的，但这篇教程非常细致，即使是今天也有可学习的地方。当做对 iOS 开发的回顾也挺不错的。 iOS 7 Best Practices; A Weather App Case Study: Part 1/2 iOS 7 Best Practices; A Weather App Case Study: Part 2/2 就是你是一个 iOS 小白，相信也能很容易学会。 知识点 主要用的技术有 Mantle（类似 YYModel）、ReactiveCocoa。 YYModel 之前分析过源码，Mantle 倒还没研究过，（印象里 YYModel 作者的测试中，Mantle 的性能是很差的，但好在稳定） 这个 App 可以当做 ReactiveCocoa 使用的入门教程，虽然只用了很少部分的功能，但还是可以感受到响应式编程的思维模式。（就这个项目用到的部分功能，个人感觉如果用之前的编程方式，也可以用 KVO 或 Notification 的方式解决，只是代码位置相对分散） 最近也有做 App 内通知 View 的需求，所以顺便学习了 TSMessage 的源码。 小问题 当时的 iPhone 还没有刘海，在我的 iPhone 13 Pro 上，UI 布局其实是有 bug 的，当然这不是重点。 另一个就是 iOS8 之后，读取位置需要授权，需要在 Info.plist 里面补充 iOS9 之后 Https 需要配置，在 Info.plist 里面补充 作者使用的免费天气 API，在我的尝试时是用不了的，现在官网会要求多加一个 appid 的参数，然而即使传了，也是返回 401。这也不是重点，所以我用了本地模拟的 json 文件去替代。 ","link":"https://jayying007.github.io/post/一个简单的天气App/"},{"title":"mmap--读写文件的另一种选择","content":"前言 在编写 C/C++等语言时，如果需要读写文件，通常会想到用 read 和 write 两个系统库接口。或者是 fread、fwrite 等标准库接口。 近期在做一个需求，为了避免数据丢失，每次有新数据时，我都会立即调用 write 相关接口写入磁盘。如果频率很高，就会造成大量的 IO。 于是开始寻找是否有能避免频繁 IO，同时又保证数据不丢失的方式，最终发现了 mmap。 mmap 介绍 mmap 是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用 read,write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。如下图所示： 相关的接口有：mmap()，munmap()，msync() 具体的用法和参数等说明，可以参考文档mmap(2) - Linux manual page 调用 mmap 接口，需要传递文件描述符 fd。而一旦创建完成，就可以关闭文件描述符了。因为映射的是磁盘的地址，不是文件本身，和文件句柄无关。 mmap 和常规文件读写的区别 常规文件读写 进程发起读文件请求。 内核通过查找进程文件符表，定位到内核已打开文件集上的文件信息，从而找到此文件的 inode。 inode 在 address_space 上查找要请求的文件页是否已经缓存在页缓存中。如果存在，则直接返回这片文件页的内容。 如果不存在，则通过 inode 定位到文件磁盘地址，将数据从磁盘复制到页缓存。之后再次发起读页面过程，进而将页缓存中的数据发给用户进程。 总结来说，常规文件操作为了提高读写效率和保护磁盘，使用了页缓存机制。这样造成读文件时需要先将文件页从磁盘拷贝到页缓存中，由于页缓存处在内核空间，不能被用户进程直接寻址，所以还需要将数据页从页缓存中再次拷贝到内存对应的用户空间中。这样，通过了两次数据拷贝过程，才能完成进程对文件内容的获取任务。写操作也是一样，待写入的 buffer 在内核空间不能直接访问，必须要先拷贝至内核空间对应的主存，再写回磁盘中（延迟写回），也是需要两次数据拷贝。 mmap 读写 进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域 调用内核空间的系统调用函数 mmap（不同于用户空间函数），实现文件物理地址和进程虚拟地址的一一映射关系 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝 **总而言之，常规文件操作需要从磁盘到页缓存再到用户主存的两次数据拷贝。而 mmap 操控文件，只需要从磁盘到用户主存的一次数据拷贝过程。**说白了，mmap 的关键点是实现了用户空间和内核空间的数据直接交互而省去了空间不同数据不通的繁琐过程。因此 mmap 效率更高。 mmap 回写时机 mmap 是映射到进程的虚拟内存空间的，如果刚 memcpy 一份数据，进程就挂了，那数据会丢失吗？ 答案是不会的，以下是 Linus 的回复： {% note %} Linus Torvalds The mapped pages are part of the filesystem cache,which means that even if the user process that made a change to that page dies, the page is still managed by the kernel and as all concurrent accesses to that file will go through the kernel, other processes will get served from that cache. In some old Linux kernels it was different, that’s the reason why some kernel documents still tell to force msync. {% endnote %} 查看 Linux 内核代码，可以发现在收到异常信号时，是会帮你把 mmap 数据写会磁盘的。 do_exit 的代码在 kernel/exit.c，里面会调用 exit_mm，exit_mm 又调用 mmput 不过正如 Linus 所说，部分老的 Linux 内核可能表现不同，所以为了确保数据回写，你可以用 msync mmap 优缺点 一路看下来，好像 mmap 完全碾压 read 系统接口？ mmap 减少了数据的拷贝次数，用内存读写取代 I/O 读写，提高了文件读取效率。 mmap 在随机访问场景下很有优势。 不过 mmap 也有一些限制，因为 mmap 映射到了进程虚拟地址空间，其最小粒度为页，所以其占用大小在内存中是页的整数倍。 当把一个文件大小不为页的倍数映射进来时，可以访问最后页其他部分，不会报错。但是对该区域的修改也不会影响原文件。 mmap 后内存大小就是固定的了，如果之后有其他地方改变了文件的大小，就会出现不一致的情况。 另外，因为文件是映射到内存空间的，如果文件很大，就会占用很多内存空间。即把文件映射到内存后，这部分内存地址就不能用做其他了，只能用于该文件读写。而且虚拟内存空间也很难找到那么大一块连续的地址。 讨论 关于什么时候用 read、write，什么时候用 mmap，StackOverflow 上有很不错的讨论： 传送门：When should I use mmap for file access? 参考资料 mmap()的原理与应用 mmap 与 read write 的对比 什么时候选择 mmap 而非 read? - 珠玑位 - 博客园 linux 中 mmap 文件到内存中，该进程发生错误被挂掉后 mmap 映射的内存能否写回到文件中的问题 ","link":"https://jayying007.github.io/post/mmap--读写文件的另一种选择/"},{"title":"深入理解Protobuf","content":"简单介绍 Protobuf 是序列化数据的一种方式。 比如在前后端的数据交互中，我们可能采用 xml 或者 json 的数据格式进行通信，而 protobuf 则是另一种选择。 相比前两者，protobuf 序列化的数据体积更小，序列化速度更快。 Protobuf 现在有 proto2 和 proto3 两个版本，这里默认使用 proto2 基本用法(以 iOS 为例) 首先创建一个 proto 文件，然后定义你的数据结构 message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; } 接着到Protobuf 的 Github 网址下载一个 protoc 编译器，用于编译上面的 proto 文件 大致命令为： protoc --proto_path=src --objc_out=build/gen src/foo.proto 具体可以参考官方教程 这样你就得到了一个 pbobjc.h 和 pbobjc.m 文件，其中就有 SearchRequest 这个类，内容大概如下 @interface SearchRequest : GPBMessage @property(nonatomic, readwrite, copy, null_resettable) NSString *query; @property(nonatomic, readwrite) BOOL hasQuery; @property(nonatomic, readwrite) int32_t pageNumber; @property(nonatomic, readwrite) BOOL hasPageNumber; @property(nonatomic, readwrite) int32_t resultPerPage; @property(nonatomic, readwrite) BOOL hasResultPerPage; @end @implementation SearchRequest @dynamic hasQuery, query; @dynamic hasPageNumber, pageNumber; @dynamic hasResultPerPage, resultPerPage; typedef struct SearchRequest__storage_ { uint32_t _has_storage_[1]; int32_t pageNumber; int32_t resultPerPage; NSString *query; } SearchRequest__storage_; + (GPBDescriptor *)descriptor { //不用关心 } @end 接下来你就可以把它当做一个 Model 来使用，或者用 Java 的术语来说，叫 PoJo 类。 当你需要序列化的时候，调用-[GPBMessage data]方法； 当你需要反序列化的时候，调用+[GPBMessage parseFromData:error:]等方法。 基本语法 还是以上面的 proto 文件举例 message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; } 1 message 定义了一种数据结构，其后跟着对应的名称。一个 proto 文件可以定义多个 message，你也可以用 import 关键字，引入其他 proto，就像代码引入头文件一样。 2 每个属性前的关键字，有三种选择：required、optional、repeated，分别对应：必填、选填、重复填（即数组） 3 随后是其数据类型，基础类型如下表 .proto Type Notes Objective-C Type double double float float int32 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint32 instead. int32_t int64 Uses variable-length encoding. Inefficient for encoding negative numbers – if your field is likely to have negative values, use sint64 instead. int64_t uint32 Uses variable-length encoding. uint32_t uint64 Uses variable-length encoding. uint64_t sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32_t sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64_t fixed32 Always four bytes. More efficient than uint32 if values are often greater than 228. uint32_t fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 256. uint64_t sfixed32 Always four bytes. int32_t sfixed64 Always eight bytes. int64_t bool BOOL string A string must always contain UTF-8 encoded text. NSString bytes May contain any arbitrary sequence of bytes. NSData 此外也可以定义枚举和 message enum Corpus { CORPUS_UNSPECIFIED = 0; CORPUS_UNIVERSAL = 1; CORPUS_WEB = 2; CORPUS_IMAGES = 3; CORPUS_LOCAL = 4; CORPUS_NEWS = 5; CORPUS_PRODUCTS = 6; CORPUS_VIDEO = 7; } message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; optional Corpus corpus = 4; } message SearchResponse { repeated Result result = 1; } message Result { required string url = 1; optional string title = 2; repeated string snippets = 3; } 另外你还可以定义 Map 类型，但 Map 本质上只是一个特殊的 message 数据结构而已。 message Example { map&lt;key_type, value_type&gt; map_field = N; } || message MapFieldEntry { optional key_type key = 1; optional value_type value = 2; } message Example { repeated MapFieldEntry map_field = N; } 4 名称不必多说，只是生成 ObjC 代码时，会将蛇形命名改为驼峰命名。 当然，一些情况也没这么简单。 5 最后就是属性的编号了，可以从 1 到 536,870,911，但一般也不会定义那么多属性。 另外需要注意的是，一旦一个属性的编号确定了，就不要随意去改动它，以避免前后版本数据兼容带来的问题。 更详细的内容，参考官方文档 编码原理 在讲具体的编码之前，有必要提一下 TLV（Tag-Length-Value）。 还是以上面的 proto 为例子 message SearchRequest { required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3; } 如果我们要编译这段数据，就可以用 TLV 的方式： 写入序号 1，你可以自己决定这个序号占多少字节，但后面所有序号就要固定这个字节数了，假设为 4 因为 query 是 string，写入字段的长度，这个占多少字节也可以自定义，假设为 4 写入 query 数据本身 写入序号 2（4 个字节） 因为 page_number 是 int32，直接 4 个字节写入其值 写入序号 3（4 个字节） 因为 result_per_page 是 int32，直接 4 个字节写入其值 只要你按照这个格式写入，解析也就很简单： 读取 4 个字节，得到序号 1 查看 proto 知道是 string 类型，接着读取 4 个字节得到长度 根据长度，读取相应的字节，得到的就是 query 的数据 读取 4 个字节，得到序号 2 查看 proto 知道是 int32 类型，所以读 4 个字节，得到的就是 page_number 的值 读取 4 个字节，得到序号 3 查看 proto 知道是 int32 类型，所以读 4 个字节，得到的就是 result_per_page 的值 按上面这种方法，我们也能实现数据的序列化和反序列化，而且效果还不错。 实际上，Protobuf 就是特殊的 TLV，在传统 TLV 的基础上，对部分数据进行精简，从而使得序列化后体积更小。 分割线 先从一个简单的例子入手，定义一个 Test1 message Test1 { optional int32 a = 1; } 然后给 a 赋值 150，接着打印 Test1 *test1 = [[Test1 alloc] init]; test1.a = 150; NSLog(@&quot;%@&quot;, test1.data); //{length = 3, bytes = 0x089601} 你会很神奇地发现，按我们刚才的做法需要 8 个字节存储，到这里 3 个字节就搞定了！！！ Protobuf 是怎么做到的呢，这就要涉及到一种核心编码方式Varints。 Varints Varints 这个词拆出来，就是 var int，即可变的 int 类型，这里的可变指的是长度可变，即 int32 不一定对应 4 个字节。因为在大部分情况下，我们都用不满 32bit，这会导致大部分 bit 位都是 0，而这就是浪费。 在 Varints 编码环境下，一个 int64 可能占 1 到 10 个字节数。每个字节的第一位是标志位（MSB - Most significant bit），剩下 7 位才是真正存储数据的。 0000 0001 ^ msb 比如编码数字 1，只需要一个字节，MSB 为 0 代表结束。 10010110 00000001 ^ msb ^ msb 编码数字 150 需要两个字节，MSB 为 1 代表后面还有数据。 计算数值时，把 MSB 去掉，因为是小端序，还要把前面的字节放到后面，再拼起来。 至此，开头的问题后两个字节 0x9601 我们已经知道是什么意思了，那第一个字节 0x08 呢。 这个字节由两部分组成，field_number 和 wire_type，组合方式是(field_number &lt;&lt; 3) | wire_type，俗称 Tag field_number 我们知道是 1，wire_type 则参考下面表格 ID Name Used For 0 VARINT int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 I64 fixed64, sfixed64, double 2 LEN string, bytes, embedded messages, packed repeated fields 3 SGROUP group start (deprecated) 4 EGROUP group end (deprecated) 5 I32 fixed32, sfixed32, float 因为 int32 属于 Varints，所以为 0，拼起来就得到了 0x08 乍一看，field_number 只有 5 个 bit，那不是最多只能定义 32 个 field 吗。其实不是，这个 Tag 也是一个 Varints，所以定义 fileid=16 应该长下面这样 Varints 的局限性和对策 Varints 并不是万能的，有些场景它是低效的。 对于 int32、int64，比如编码一个-2，需要花费 10 个字节 11111110 11111111 11111111 11111111 11111111 11111111 11111111 11111111 11111111 00000001 对于 sint32、sint64，则换了种思路，先采用 ZigZag 算法，然后再用 Varints 编码。 ZigZag 规则为，如果是负数，则存储其绝对值的 2 倍减 1；如果为非负数，则存储其绝对值的 2 倍。这样就有效降低了负数占用的字节空间。 剩下的 wire type 中， I64 和 I32，代表读取固定 8 个字节和 4 个字节。 LEN 则代表数据的长度需要由下一个数据确定。 比如下面这个例子 message Test2 { optional string b = 2; } Test2 *test2 = [[Test2 alloc] init]; test2.b = @&quot;hello world&quot;; NSLog(@&quot;%@&quot;, test2.data); // {length = 13, bytes = 0x120b68656c6c6f20776f726c64} 需要注意这个长度 11 也是 Varints 编码。 剩下的 bytes、message 也是类似的解析。 message Test3 { optional Test1 c = 3; } // 按开头的Test1，它编码后是这样的 // 1a 03 [08 96 01] repeated 的解析 repeated 在 proto2 和 proto3 上的存储稍有不同。 message Test4 { repeated bool d = 1; } // proto2: 0x080108000800 // proto3: 0x0a03010000 比如上面这个数据，假设我设置了 YES、NO、NO 三个数据。 在 proto2 中占了 6 个字节，而在 proto3 中占了 5 个字节 解码浅析 解码其实没什么好说的，就是编码反过来而已。 这里主要补充一下对重复消息的处理，即在数据流中解析到一个 fileid，后面又再解析到这个 field 该如何处理： 如果字段为不可分割的类型，则直接覆盖 如果字段为 repeated，则 append 到已有字段。其实上文 proto2 中已经可以很清晰看到这点了。 如果字段为嵌套消息，则递归执行 merge 参考资料 https://protobuf.dev/programming-guides/proto/ https://protobuf.dev/programming-guides/encoding/ https://github.com/protocolbuffers/protobuf ","link":"https://jayying007.github.io/post/深入理解Protobuf/"},{"title":"JSPatch源码笔记","content":"https://github.com/bang590/JSPatch 作者居然是校友，哈哈哈 其实在 Github 的 Wiki 上，已经有很详细的原理说明了，所以这里纯粹作为我个人阅读源码的笔记。 这个项目对于学习 ObjC runtime、JavaScriptCore 的应用都是不错的选择，建议参考文档用 Safari 调试下 JS 代码。 defineClass 方法替换 如果是替换方法，会给原 Class 加入新的 Method，selector 为原方法名称加上 ORIG 前缀，IMP 则指向原方法。 原方法的 IMP 则修改为_objc_msgForward，即强制走转发流程。 IMP msgForwardIMP = _objc_msgForward; if (class_respondsToSelector(cls, selector)) { NSString *originalSelectorName = [NSString stringWithFormat:@&quot;ORIG%@&quot;, selectorName]; SEL originalSelector = NSSelectorFromString(originalSelectorName); if(!class_respondsToSelector(cls, originalSelector)) { class_addMethod(cls, originalSelector, originalImp, typeDescription); } } _JSOverideMethods[cls][JPSelectorName] = function; class_replaceMethod(cls, selector, msgForwardIMP, typeDescription); 这个过程同时将 JS 函数记录下来。（_JSOverideMethods） 在 JS 中，也会将该方法记下来（_ocCls） var _setupJSMethod = function(className, methods, isInst, realClsName) { for (var name in methods) { var key = isInst ? 'instMethods': 'clsMethods', func = methods[name] _ocCls[className][key][name] = _wrapLocalMethod(name, func, realClsName) } } ... ... var ret = _OC_defineClass(declaration, newInstMethods, newClsMethods) var className = ret['cls'] var superCls = ret['superCls'] _ocCls[className] = { instMethods: {}, clsMethods: {}, } _setupJSMethod(className, instMethods, 1, realClsName) _setupJSMethod(className, clsMethods, 0, realClsName) return require(className) 最后的 require 相当于在 JS 的全局变量中声明了这个变量，后续 JS 代码调用就不会找不到该变量了。 方法添加 方法添加其实跟上面的流程很像，最后也是利用 class_replaceMethod 这个函数进行方法插入。只不过没有原方法，所以其 IMP 直接就是_objc_msgForward 运行 在一些小型 patch 上，defineClass 基本就能解决问题了。在 JS 解析过程中，无非就是将这些类、方法的信息做一下存储记录。 直到 App 真正运行，执行到了被替换的方法，然后来到了 JPForwardInvocation 这个函数。 static void JPForwardInvocation(__unsafe_unretained id assignSlf, SEL selector, NSInvocation *invocation); 这里从 NSInvocation 能拿到返回值、调用者、调用方法名、调用参数。 结合上面保存的信息，就能找到对应的 JS 函数，执行该函数。 JS 函数里面，因为在解析 JS 脚本之前，所有的方法调用已经被转为__c()这种方法调用 handleBtn: function(sender) { var tableViewCtrl = JPTableViewController.__c(&quot;alloc&quot;)().__c(&quot;init&quot;)() self.__c(&quot;navigationController&quot;)().__c(&quot;pushViewController_animated&quot;)(tableViewCtrl, YES) } __c: function(methodName) { var slf = this if (slf instanceof Boolean) { return function() { return false } } if (slf[methodName]) { return slf[methodName].bind(slf); } if (!slf.__obj &amp;&amp; !slf.__clsName) { throw new Error(slf + '.' + methodName + ' is undefined') } if (slf.__isSuper &amp;&amp; slf.__clsName) { slf.__clsName = _OC_superClsName(slf.__obj.__realClsName ? slf.__obj.__realClsName: slf.__clsName); } var clsName = slf.__clsName if (clsName &amp;&amp; _ocCls[clsName]) { var methodType = slf.__obj ? 'instMethods': 'clsMethods' if (_ocCls[clsName][methodType][methodName]) { slf.__isSuper = 0; return _ocCls[clsName][methodType][methodName].bind(slf) } } return function(){ var args = Array.prototype.slice.call(arguments) return _methodFunc(slf.__obj, slf.__clsName, methodName, args, slf.__isSuper) } } __c 方法先在之前的记录列表里面查找是否有该 JS Function，如果有的话则返回对应的 JS Function。 如果没有，则调用_methodFunc。 var _methodFunc = function ( instance, clsName, methodName, args, isSuper, isPerformSelector ) { var selectorName = methodName; if (!isPerformSelector) { methodName = methodName.replace(/__/g, &quot;-&quot;); selectorName = methodName.replace(/_/g, &quot;:&quot;).replace(/-/g, &quot;_&quot;); var marchArr = selectorName.match(/:/g); var numOfArgs = marchArr ? marchArr.length : 0; if (args.length &gt; numOfArgs) { selectorName += &quot;:&quot;; } } var ret = instance ? _OC_callI(instance, selectorName, args, isSuper) : _OC_callC(clsName, selectorName, args); return _formatOCToJS(ret); }; _methodFunc 也是一个很关键的方法，它实现了 JS 调用任意 OC 方法，不难猜到，_OC_callI 和_OC_callC 的实现逻辑大概就是：根据 clsName 和 selector，找到对应的 IMP，然后执行。 到这里，JSPatch 的核心原理已经讲完了。代码不算多，但实现很精妙。 细节部分 super 以 viewDidLoad 为例 viewDidLoad: function() { self.__c(&quot;super&quot;)().__c(&quot;viewDidLoad&quot;)() } JS 上为 Object 定义了 super 方法，可以简单理解为打了一个__isSuper 的标记。 super: function() { var slf = this if (slf.__obj) { slf.__obj.__realClsName = slf.__realClsName; } return {__obj: slf.__obj, __clsName: slf.__clsName, __isSuper: 1} } 之后执行 viewDidLoad 方法时，将该信息传递给了 callSector if (isSuper) { NSString *superSelectorName = [NSString stringWithFormat:@&quot;SUPER_%@&quot;, selectorName]; SEL superSelector = NSSelectorFromString(superSelectorName); Class superCls; if (realClsName.length) { Class defineClass = NSClassFromString(realClsName); superCls = defineClass ? [defineClass superclass] : [cls superclass]; } else { superCls = [cls superclass]; } Method superMethod = class_getInstanceMethod(superCls, selector); IMP superIMP = method_getImplementation(superMethod); class_addMethod(cls, superSelector, superIMP, method_getTypeEncoding(superMethod)); NSString *JPSelectorName = [NSString stringWithFormat:@&quot;_JP%@&quot;, selectorName]; JSValue *overideFunction = _JSOverideMethods[superCls][JPSelectorName]; if (overideFunction) { overrideMethod(cls, superSelectorName, overideFunction, NO, NULL); } selector = superSelector; superClassName = NSStringFromClass(superCls); } 这里查找了 superclass，以及对应 selector 的 IMP 实现，并将其以前缀 SUPER_的形式加入当前类的方法列表。 struct JSValue 原生支持了几种常见结构体的转换 @interface JSValue (StructSupport) /*! @method @abstract Convert a JSValue to a CGPoint. @discussion Reads the properties named &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; from this JSValue, and converts the results to double. @result The new CGPoint. */ - (CGPoint)toPoint; /*! @method @abstract Convert a JSValue to an NSRange. @discussion Reads the properties named &lt;code&gt;location&lt;/code&gt; and &lt;code&gt;length&lt;/code&gt; from this JSValue and converts the results to double. @result The new NSRange. */ - (NSRange)toRange; /*! @method @abstract Convert a JSValue to a CGRect. @discussion Reads the properties named &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt;, &lt;code&gt;width&lt;/code&gt;, and &lt;code&gt;height&lt;/code&gt; from this JSValue and converts the results to double. @result The new CGRect. */ - (CGRect)toRect; /*! @method @abstract Convert a JSValue to a CGSize. @discussion Reads the properties named &lt;code&gt;width&lt;/code&gt; and &lt;code&gt;height&lt;/code&gt; from this JSValue and converts the results to double. @result The new CGSize. */ - (CGSize)toSize; @end 不过 JSPatch 支持传递自定义的结构体，不过这需要在 JSExtension 中提前定义好结构体的信息。 其实 JSPatch 传过来的参数就是一个 NSDictionary，而结构体无非就是 malloc 一段内存块，然后根据结构信息在不同的地址写入数值。 case '{': { NSString *typeString = extractStructName([NSString stringWithUTF8String:argumentType]); JSValue *val = arguments[i-2]; #define JP_CALL_ARG_STRUCT(_type, _methodName) \\ if ([typeString rangeOfString:@#_type].location != NSNotFound) { \\ _type value = [val _methodName]; \\ [invocation setArgument:&amp;value atIndex:i]; \\ break; \\ } JP_CALL_ARG_STRUCT(CGRect, toRect) JP_CALL_ARG_STRUCT(CGPoint, toPoint) JP_CALL_ARG_STRUCT(CGSize, toSize) JP_CALL_ARG_STRUCT(NSRange, toRange) @synchronized (_context) { NSDictionary *structDefine = _registeredStruct[typeString]; if (structDefine) { size_t size = sizeOfStructTypes(structDefine[@&quot;types&quot;]); void *ret = malloc(size); getStructDataWithDict(ret, valObj, structDefine); [invocation setArgument:ret atIndex:i]; free(ret); break; } } break; } 自定义结构体的赋值可以查看 getStructDataWithDict 方法。 C Function 这个用了 ffi 库。 大致思路就是通过函数名，利用 dlsym 找到对应 C 函数的函数地址，然后就能执行了。 block 这个也是用了 ffi 库，但是调试时 block 调用错误，issue 也有不少反馈，可能跟 iOS 的 block 结构改变有关？ 不过也不影响原理的理解 global.block = function (args, cb) { var that = this; var slf = global.self; if (args instanceof Function) { cb = args; args = &quot;&quot;; } var callback = function () { var args = Array.prototype.slice.call(arguments); global.self = slf; return cb.apply(that, _formatOCToJS(args)); }; var ret = { args: args, cb: callback, argCount: cb.length, __isBlock: 1 }; if (global.__genBlock) { ret[&quot;blockObj&quot;] = global.__genBlock(args, cb); } return ret; }; JS 这里给 block 打上标记，同时结合 JPBlock 创建了一个 BlockWrapper 传递给 OC。 这个 BlockWrapper 包含了函数的签名信息，以及对应的 JS Function。所以调用原 block，可以理解为创建一个新的 block，这个 block 里面再利用[JSValue callWithArgument:]调用到原 block ","link":"https://jayying007.github.io/post/JSPatch源码笔记/"},{"title":"[转] iOS APP可执行文件的组成","content":"个人感觉这个标题起得不是很好，会误认为是分析 Math-O 文件，实际上是统计代码组成。 出于好奇看了下作者，原来是 JSPatch 的作者，而且还是校友，甚至还是同事，世界真奇妙~ 原文链接：iOS APP 可执行文件的组成 « bang’s blog iOS APP 编译后，除了一些资源文件，剩下的就是一个可执行文件，有时候项目大了，引入的库多了，可执行文件很大，想知道这个可执行文件的构成是怎样，里面的内容都是些什么，哪些库占用空间较高，可以用以下方法勘察： 1.XCode 开启编译选项 Write Link Map File XCode -&gt; Project -&gt; Build Settings -&gt; 搜 map -&gt; 把 Write Link Map File 选项设为 yes，并指定好 linkMap 的存储位置 2.编译后，到编译目录里找到该 txt 文件，文件名和路径就是上述的 Path to Link Map File 位于~/Library/Developer/Xcode/DerivedData/XXX-eumsvrzbvgfofvbfsoqokmjprvuh/Build/Intermediates/XXX.build/Debug-iphoneos/XXX.build/ 这个 LinkMap 里展示了整个可执行文件的全貌，列出了编译后的每一个.o 目标文件的信息（包括静态链接库.a 里的），以及每一个目标文件的代码段，数据段存储详情。 1 以伊书项目为例，在 LinkMap 里首先列出来的是目标文件列表： # Object files: [ 0] linker synthesized [ 1] /Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator7.0.sdk/usr/lib/crt1.o [ 2] /Users/bang/Library/Developer/Xcode/DerivedData/yishu-eyzgphknrrzpevagadjtwpzzeqag/Build/Intermediates/yishu.build/Debug-iphonesimulator/yishu.build/Objects-normal/i386/TKPFileInfo.o ... [280] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANJob.o) [281] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANWorker.o) [282] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(MobClick.o) [283] /Users/bang/Downloads/yishu/yishu/Classes/lib/UMeng/MobClick/libMobClickLibrary.a(UMANLaunch.o) ... 前面中括号里的是这个文件的编号，后面会用到，像项目里引用到静态链接库 libMobClickLibrary.a 里的目标文件都会在这里列出来。 2 接着是一个段表，描述各个段在最后编译成的可执行文件中的偏移位置及大小，包括了代码段（**TEXT，保存程序代码段编译后的机器码）和数据段（**DATA，保存变量值） # Sections: # Address Size Segment Section 0x00002740 0x00273890 __TEXT __text 0x00275FD0 0x00000ADA __TEXT __symbol_stub 0x00276AAC 0x00001222 __TEXT __stub_helper 0x00277CCE 0x00019D9E __TEXT __objc_methname 0x00291A70 0x00012847 __TEXT __cstring 0x002A42B7 0x00001FC1 __TEXT __objc_classname 0x002A6278 0x000046A7 __TEXT __objc_methtype 0x002AA920 0x000061CE __TEXT __ustring 0x002B0AF0 0x00000764 __TEXT __const 0x002B1254 0x000028B8 __TEXT __gcc_except_tab 0x002B3B0C 0x00004EBC __TEXT __unwind_info 0x002B89C8 0x0003662C __TEXT __eh_frame 0x002EF000 0x00000014 __DATA __program_vars 0x002EF014 0x00000284 __DATA __nl_symbol_ptr 0x002EF298 0x0000073C __DATA __la_symbol_ptr 0x002EF9E0 0x000030A4 __DATA __const 0x002F2A84 0x00000590 __DATA __objc_classlist 0x002F3014 0x0000000C __DATA __objc_nlclslist 0x002F3020 0x0000006C __DATA __objc_catlist 0x002F308C 0x000000D8 __DATA __objc_protolist 0x002F3164 0x00000008 __DATA __objc_imageinfo 0x002F3170 0x0002BC80 __DATA __objc_const 0x0031EDF0 0x00003A30 __DATA __objc_selrefs 0x00322820 0x00000014 __DATA __objc_protorefs 0x00322834 0x000006B8 __DATA __objc_classrefs 0x00322EEC 0x00000394 __DATA __objc_superrefs 0x00323280 0x000037C8 __DATA __objc_data 0x00326A48 0x000096D0 __DATA __cfstring 0x00330118 0x00001424 __DATA __objc_ivar 0x00331540 0x00006080 __DATA __data 0x003375C0 0x0000001C __DATA __common 0x003375E0 0x000018E8 __DATA __bss 首列是数据在文件的偏移位置，第二列是这一段占用大小，第三列是段类型，代码段和数据段，第四列是段名称。 每一行的数据都紧跟在上一行后面，如第二行symbol_stub 的地址 0x00275FD0 就是第一行text 的地址 0x00002740 加上大小 0x00273890，整个可执行文件大致数据分布就是这样。 这里可以清楚看到各种类型的数据在最终可执行文件里占的比例，例如**text 表示编译后的程序执行语句，**data 表示已初始化的全局变量和局部静态变量，**bss 表示未初始化的全局变量和局部静态变量，**cstring 表示代码里的字符串常量，等等。 3 接着就是按上表顺序，列出具体的按每个文件列出每个对应字段的位置和占用空间 # Address Size File Name 0x00002740 0x0000003E [ 1] start 0x00002780 0x00000400 [ 2] +[TKPFileInfo parseWithDictionary:] 0x00002B80 0x00000030 [ 2] -[TKPFileInfo fileID] ... 同样首列是数据在文件的偏移地址，第二列是占用大小，第三列是所属文件序号，对应上述 Object files 列表，最后是名字。 例如第二行代表了文件序号为 2（反查上面就是 TKPFileInfo.o）的 parseWithDictionary 方法占用了 1000byte 大小。 使用 这个文件可以让你了解整个 APP 编译后的情况，也许从中可以发现一些异常，还可以用这个文件计算静态链接库在项目里占的大小，有时候我们在项目里链了很多第三方库，导致 APP 体积变大很多，我们想确切知道每个库占用了多大空间，可以给我们优化提供方向。LinkMap 里有了每个目标文件每个方法每个数据的占用大小数据，所以只要写个脚本，就可以统计出每个.o 最后的大小，属于一个.a 静态链接库的.o 加起来，就是这个库在 APP 里占用的空间大小。 写了个 nodejs 版统计程序可供使用：https://gist.github.com/bang590/8f3e9704f1c2661836cd ","link":"https://jayying007.github.io/post/[转] iOS APP可执行文件的组成/"},{"title":"Xcode开发插件","content":"最近在考古一些 iOS 博客，发现还能用 Xcode 来写插件。 Github 上有一些 star 数很高的开源项目，比如 自动填充图片名称：https://github.com/ksuther/KSImageNamed-Xcode 显示 RGB 颜色：https://github.com/omz/ColorSense-for-Xcode 也能搜到一些不错的入门教程 Xcode 4 插件制作入门 How To Create an Xcode Plugin: Part 1/3 本来想自己整个插件玩玩，但试了几个插件都用不了，最后 Google 才发现 Xcode8 开始已经不支持插件了，具体可以看这个讨论Xcode 8 won’t load plug-ins · Issue #475 · alcatraz/Alcatraz 苹果在《WWDC 2016 session about source editor extensions》中整了一个新的玩意，但是这玩意限制太大，只能处理 Xcode 内的代码编辑，做不了代码提示这么灵活的事情了。 比如这个项目https://github.com/iDevOrz/JYLazyLoader，根据 property 自动生成懒加载方法。 fuck Apple！！！ ","link":"https://jayying007.github.io/post/Xcode开发插件/"},{"title":"正式记录语雀第一篇文章","content":"前言 这个标题可能有点误导，因为我从 2020 年就开始用语雀了。 这里指的其实是用语雀在我的博客发布文章。 2021 年白嫖一台服务器之后，就在上面搭建了个人博客，也发了一些文章。这里写文章需要使用 Markdown 语法，当时用的是 Typora+PicGo 组合，其实也还不错。 不过自建的 Hexo 博客其实特性并没有语雀那么多，就编辑体验而言，也是语雀优一些。另外你也需要同时维护博客和语雀两套系统。 综合这些因素，后面我的文章主要输出都在语雀上。2022 年我的个人博客基本没有产出了。 另外，虽然语雀上面的文章也是公开的，但是猜测是因为反爬策略，搜索引擎上也找不到文章。 于是有了需求：在语雀上面编辑文章，然后自动发布到个人博客上。 开搞吧 🔨 用流程图来表示，大概如图所示 在语雀上写完文章后，通过 WebHook 的方式通知到博客服务器； 服务器通过语雀 Token，访问其开放 API 读取文章； 通过 hexo 命令重新生成静态网站、部署。 WebHook 可以在知识库设置里面选择 服务器的话，其实我们只是想收到 Push 通知，然后调用脚本执行相关命令。 这里选择了最简单的 Nodejs 搭建服务器，代码如下 //导入第三方模块：express，创建基于Node.js的Web服务器 let express = require(&quot;express&quot;); const { exec } = require(&quot;child_process&quot;); //调用第三方模块提供的功能 let server = express(); //运行Web服务器监听特定的端口 let port = 5050; server.listen(port, function (req, rsp) { console.log(&quot;服务器启动成功，正在监听端口：&quot;, port); }); var isRuningScript = false; server.post(&quot;/yuque/xxx&quot;, function (req, res) { console.log(&quot;receive notify from yuque&quot;); if (isRuningScript) { console.log(&quot;is running&quot;); return; } isRuningScript = true; exec(&quot;xxx.sh&quot;, (err, stdout, stderr) =&gt; { // console.log(`stdout: ${stdout}`); // console.log(`stderr: ${stderr}`); isRuningScript = false; if (err) { console.log(&quot;fail to execute shell&quot;); return; } console.log(&quot;website is redeploy&quot;); }); }); 然后在后台运行 node main.js &gt;log.txt 2&gt;&amp;1 &amp; 脚本的逻辑分为两部分：拉取语雀文章、重新部署 hexo。 拉取语雀文章，这里可以使用现有轮子yuque-hexo。 这样我们的脚本就大概如下 YUQUE_TOKEN=xxx yuque-hexo sync hexo clean hexo generate hexo deploy 进一步 ❓ 上面已经解决了语雀发布文章，自动同步个人博客。不过观察上面的流程，你会发现我们把 Hexo 整个文件夹都放到服务器上面了。如果我想换个博客主题或者调整下配置，就只能到服务器上面改了。 这显然很不方便，实际上，为了知道某个配置是否调整合适，你还是需要本地运行看一遍。 于是需求又来了：本地修改配置，提交 Commit 后能自动更新博客样式。 整个流程如下： Github 上面也有 WebHook，服务器沿用 Nodejs 的代码即可，和语雀很相似，给个新接口区分下 server.post(&quot;/github/yyy&quot;, function (req, res) { console.log(&quot;receive notify from github&quot;); if (isRuningScript) { console.log(&quot;is running&quot;); return; } isRuningScript = true; exec(&quot;yyy.sh&quot;, (err, stdout, stderr) =&gt; { // console.log(`stdout: ${stdout}`); // console.log(`stderr: ${stderr}`); isRuningScript = false; if (err) { console.log(&quot;fail to execute shell&quot;); return; } console.log(&quot;website is redeploy&quot;); }); }); 这里因为不存在语雀文档的更新，所以脚本只是更新代码、重新部署 Hexo。 npm update git fetch origin master git reset --hard origin/master git submodule update hexo clean hexo generate hexo deploy 这样就好了吗 要知道，我原先 Hexo 上面有好些文章的，但是使用 yuque-hexo 插件之后，它把我的文章全删掉了，替换为语雀上的文章。 但我还想保留原先 Hexo 上的文章，一种做法是修改 yuque-hexo 的代码，把那段删除的逻辑给去掉，实际上我已经提了· Issue #135 · x-cold/yuque-hexo 前端的逻辑我不太熟。实际上，还有一种方法不用改 yuque-hexo 代码就能实现上面的效果： 在提交 Hexo 代码的时候，将其中的文章 copy 到某个路径，也做提交。然后博客服务器拉取代码时，就能把这部分也拉下来。后面执行 yuque-hexo 清理了原路径后，把 copy 的那份再挪回去就可以了。 为了实现这个逻辑，大概需要如下修改： 利用 Git hooks，在 pre-commit 和 commit-msg 中加上以下代码 origin_post_dir=source/_posts_origin if [ ! -d &quot;$origin_post_dir&quot; ]; then mkdir $origin_post_dir fi exec cp source/_posts/* $origin_post_dir 在 post-commit 加上以下代码 git add source/_posts_origin git commit --no-verify -m &quot;auto commit _posts_origin&quot; 之后拉取语雀的脚本做下更新 YUQUE_TOKEN=xxx yuque-hexo sync cp source/_posts_origin/* source/_posts hexo clean hexo generate hexo deploy 这样做完就很完美了_ 扩展 在网上查找资料的时候，发现大多数都是用的 Github Action、Github Pages 等自动化部署方案，毕竟只有我的服务器是白嫖的 🐶。如果是这种需求的，可以参考这些： 如何将语雀文章发布到 Hexo 博客 Hexo：语雀云端写作 Github Actions 持续集成 | HONGWEI 另一个点是，如果你并不追求及时同步语雀的文章到博客上，你完全不需要 WebHook，不需要搭建 Nodejs 服务器。 只需要在服务器上写一个定时脚本，定期拉取语雀和拉取代码即可。 其他资料 语雀的开放 API 文档开发者文档 我的 Hexo Next 主题 https://github.com/jayying007/hexo-theme-next ","link":"https://jayying007.github.io/post/正式记录语雀第一篇文章/"},{"title":"神秘的RSS","content":"春节放假时偶然间搜到RSS这个玩意，闲来无事，就稍微研究了一下。 我本人是不大喜欢手机上装一大堆App的，但我又想知道外界发生了什么事情。所以我一直用“今日热榜“这款App来跟踪一些热新闻。 在iPhone上，需要用一个外国区的账号，才能在App Store上搜到这个App，国内由于一些不可抗拒的原因被下线了。 RSS简介 RSS其实跟我上面提到的那款App很类似，不过借助一些插件，可以抓取到更细节的一些信息。 我不打算详细介绍，这里有篇不错的文章 RSS原理浅析 看阮一峰的两个RSS源，其实就是一些Xml数据。 https://feeds.feedburner.com/ruanyifeng https://www.ruanyifeng.com/blog/atom.xml 只要知道这个Xml的结构，我们完全可以自己写一个RSS阅读器，甚至不需要自己做内容渲染，内嵌一个WebView即可。 从这里也可以看出，我们不在乎RSS源是从哪里来的，只要它能返回Xml数据就行，于是就有了RSSHub这样的中间人。 RSSHub RSSHub官网被墙了，我很诧异。不过自己搭建难度也不高，比如我这个博客就部署了RSSHub，http://www.zhuangjieying.com:1200 #用docker真的很方便 sudo docker run -d --name rsshub -p 1200:1200 -e CACHE_EXPIRE=3600 diygod/rsshub 一开始我以为RSSHub是爬取了对应网站的数据，然后请求时再拼接成Xml返回给我们。 但我试了订阅Bilibili的视频评论，发现它其实是调用了Bilibili的API。 例如这个：https://api.bilibili.com/x/v2/reply?type=1&amp;oid=BV1L24y1z7sw&amp;sort=0 当然，应该不一定有那么多网站有这种开放能力，所以RSSHub应该是用了各种不同的抓取策略。 ","link":"https://jayying007.github.io/post/LUXfkV4cdh/"},{"title":"IOS音频技术（一）Audio Session","content":"简介 Audio Session是IOS提供的一个用来管理音频的类。通过Audio Session，你可以描述如何处理你的App的音频跟其他App的音频的关系。同时也可以告诉操作系统你将如何使用硬件设备，比如麦克风、扬声器。Audio Session是我们跟音频硬件打交道的中介。 系统提供了AVAudioSession这个类来代表Audio Session，它是一个单例，在App启动之后系统会自动初始化。主要提供的功能有以下： 设置App的音频表现形式 接受Audio Session相关通知，比如AudioInterrupt、RouteChange 配置音频设备的一些播放参数，如采样率、通道数 设置App的音频表现形式 比如当你想播放音频时，其他App也在播放音频。这时候你有几种选择： 暂停其他App的音频（需要其他App是non-mixable） 一起播放（自己或其他App是mixable） 一起播放但是减少其他App的音量。 系统提供了很多种Category，通过设置不同的Category，可以表明你的App的音频表现，具体看下面这张表： Category 按下静音键or锁屏时静音 中断其他无法混合播放的App 允许输入（录音）和输出（播放） AVAudioSessionCategoryAmbient Yes No 只有输出 AVAudioSessionCategorySoloAmbient (Default) Yes Yes 只有输出 AVAudioSessionCategoryPlayback No Yes 只有输出 AVAudioSessionCategoryRecord No (锁屏时继续录音) Yes 只有输入 AVAudioSessionCategoryPlayAndRecord No Yes 输入和输出 AVAudioSessionCategoryMultiRoute No Yes 输入和输出 注意最后一个Category，苹果的定义是： The category for routing distinct streams of audio data to different output devices at the same time. 就是虽然可以扬声器和耳机同时播放，但需要是不同的音频流 上述一些打断其他App播放的Category，如果你想实现混合播放，则可通过增加Option：AVAudioSessionCategoryOptionMixWithOthers来实现。 完整的API是这个：setCategory:mode:options:error:,这里还有一个Mode参数，它的主要作用是在不同音频场景下，让系统做相关的信号处理优化，见下表： Mode identifiers Compatible categories AVAudioSessionModeDefault All AVAudioSessionModeMoviePlayback AVAudioSessionCategoryPlayback AVAudioSessionModeVideoRecording AVAudioSessionCategoryPlayAndRecord``AVAudioSessionCategoryRecord AVAudioSessionModeVoiceChat AVAudioSessionCategoryPlayAndRecord AVAudioSessionModeGameChat AVAudioSessionCategoryPlayAndRecord AVAudioSessionModeVideoChat AVAudioSessionCategoryPlayAndRecord AVAudioSessionModeSpokenAudio AVAudioSessionCategoryPlayback AVAudioSessionModeMeasurement AVAudioSessionCategoryPlayAndRecord``AVAudioSessionCategoryRecord``AVAudioSessionCategoryPlayback 一个例子 比如你要实现音频可以在后台播放，如果有其他App的音频则降低其音量，代码如下： [[AVAudioSession sharedInstance] setActive:NO error:nil]; [[AVAudioSession sharedInstance] setCategory:AVAudioSessionCategoryPlayback withOptions:AVAudioSessionCategoryOptionDuckOthers error:nil]; [[AVAudioSession sharedInstance] setActive:YES error:nil]; 注意需要在Xcode的Capabilities中开启Background Mode 有时我们要播放App时，需要判断其他App是否在使用Audio，这时可通过secondaryAudioShouldBeSilencedHint这个属性来获取，为true时说明在playing。据此配置AudioSession和UI层的表现 有个比较蛋疼的设定是：你无法中断其他Mixable的音频。也就是说如果其他App配置了Mixable，那你的App播放的音频一定会跟它混播，而不能单独播放。 AudioSession的通知 常用的通知有以下几个： AudioInterrupt 指正在播放的音频被中断了，比如系统来电、闹钟、其他不允许一起播放的App启动了音频播放。这个时候你App的AudioSession会被系统Deactive掉，也就静音了。 代码模板如下： - (void)viewDidLoad { [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onAudioInterrupt:) name:AVAudioSessionInterruptionNotification object:nil]; } - (void)onAudioInterrupt:(NSNotification *)notification { NSDictionary *userInfo = [notification userInfo]; NSNumber *value = (NSNumber *)userInfo[AVAudioSessionInterruptionTypeKey]; if ([value intValue] == AVAudioSessionInterruptionTypeBegan) { NSLog(@&quot;interrupt begin&quot;); //保存播放上下文 } else if ([value intValue] == AVAudioSessionInterruptionTypeEnded) { NSLog(@&quot;interrupt end&quot;); //根据情况看看是否恢复播放 } } 当然，你可以在中断开始的时候又恢复播放，有机会把其他App暂停掉😜，使得有你App在其他App就不能播放，不过相信你会被用户投诉的。 RouteChange 用户插拔耳机，使得输入输出音频设备有变化时触发该通知。系统遵循Last in wins原则，output的设备是最后插入的，且有以下表现：（有时拿下耳机声音还在，诡异。。） 代码模板： - (void)viewDidLoad { [super viewDidLoad]; [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(onRouteChange:) name:AVAudioSessionRouteChangeNotification object:nil]; } - (void)onRouteChange:(NSNotification *)notification { NSLog(@&quot;routeChange&quot;); NSDictionary *userInfo = notification.userInfo; NSNumber *value = userInfo[AVAudioSessionRouteChangeReasonKey]; if ([value intValue] == AVAudioSessionRouteChangeReasonNewDeviceAvailable) { NSLog(@&quot;new device in&quot;); //遍历[AVAudioSession sharedInstance].currentRoute.outputs，看看是什么接入 } else if ([value intValue] == AVAudioSessionRouteChangeReasonOldDeviceUnavailable) { NSLog(@&quot;old device remove&quot;); AVAudioSessionRouteDescription *previousRoute = userInfo[AVAudioSessionRouteChangePreviousRouteKey]; NSLog(@&quot;previous: %@&quot;, previousRoute); NSLog(@&quot;current: %@&quot;, [AVAudioSession sharedInstance].currentRoute); } } 配置音频设备参数 主要有几个 setPreferredSampleRate：设置采样率（但最终系统采用的不一定是这个） setPreferredIOBufferDuration：时间越小延迟越低，但是I/O会更频繁 setPreferredInput：设置输入 ... 代办 取下一只耳机，音乐暂停 参考资料 https://developer.apple.com/library/archive/documentation/Audio/Conceptual/AudioSessionProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40007875-CH1-SW1 https://mikemikezhu.github.io/dev/2019/02/19/audio-session.html ","link":"https://jayying007.github.io/post/IOS音频技术（一）Audio-Session/"},{"title":"数字音频技术介绍","content":"1 声音 音频技术是为了记录、存储和回放声学现象才发明的，了解声学现象对学习数字音频是有很大帮助。 我们都知道，声音是由物体振动而产生的。当拍打某个物体时，物体的振动引起空气分子有节奏的振动，使周围的空气产生疏密变化，形成疏密相间的纵波，从而产生声波。 声波的三要素是：音调、响度、音色。 音调：又称频率，频率高的波长短，人耳能听到的频率范围大概为20Hz~20kHz 响度：又称振幅，代表着能量的大小，常用分贝DB来描述响度的大小 音色：振动的介质不同，波形也不同，听起来自然不一样 一般来说，一个物体发出的声波频率都是固定的（人的声带引起不同部位振动，能同时产生不同频率），假设我们以一定频率敲击杯子，其表现将会是下面这样：随着时间的变化，其振幅以固定频率上下波动 不过现实生活中我们听到的声音都是多个声波混合而成的，比如下面这张图（实际声音信号是连续的，下面这张图是离散的，这里忽略）： 此处来一个🐮🍺的技术：傅立叶变换，它能够将上述的时域图转为频域图。 在频域图下我们可以对特定频率做处理，然后再变换回去，从而达到对音频的特殊处理。 题外话🤔 人的声带引起不同部位振动，能同时产生不同频率。 比较有意思的一点是主动降噪耳机，通过产生一个跟外界声音相位相反的音频，使声音抵消了。 https://vdn1.vzuu.com/SD/56bfedde-1f57-11eb-abed-422f8ef9d330.mp4?disable_local_cache=1&amp;auth_key=1639326243-0-0-5b107e55ec782294b920c439212d28e1&amp;f=mp4&amp;bu=pico&amp;expiration=1639326243&amp;v=hw 2 数字音频的采集 主要涉及将模拟信号转为数字信号，这个概念在计算机网络中同样有介绍到。主要过程有：采样、量化、编码。 采样：在时间轴上对信号进行数字化，比如每隔0.01s采集一次，此时采样频率为 1/0.01 = 100Hz 量化：在振幅轴上对信号进行数字化，比如用16bit来表示一个采样，则振幅范围可以分为65536层 编码：采集到的数据如何存储，是顺序存储还是压缩存储，取决于你采用的编码格式，比如常见的wav、mp3。一般来说，采集到的音频裸数据都是很大的，需要采用合适的音频压缩技术减小其大小。 3 数字音频的表示 脉冲调制编码（Pluse Code Modulation，PCM），是使用最多的无压缩音频格式，其实就是上一节声音采集到的裸数据。 描述一段PCM数据通常需要以下几个概念： 采样率（SampleRate）：在前面有提到 声道数（Channel）：常见的就是单声道或者立体声道 位深度（Depth）：前面提到的量化 根据这些信息，我们可以计算一段PCM音频1s会产生多少数据，或者知道总大小反推PCM音频的时长。 比如CD的音质：采样率44100，双声道，16bit深度，则1秒产生的数据大小为：1 * 44100 * 2 * 16 = 1411200（bit） = 176400（bytes） = 172.3KB 除了上面几个外，描述音频数据的还有下面几个术语： 样本（Sample）：代表采集到的一条通道的数据 帧（Frame）：某一时刻所有Sample的集合，比如立体声下，一个Frame包含两个Samle，分别为左声道和右声道的 包（Packet）：一个或多个连续的Frame，在linear PCM下，一个Packet总是对应一个Frame。其他压缩的音频格式，一个Packet则可能对应多个Frame。一个Packet是一组具有意义的最少Frames的集合（就好像一组方程式，只有它们在一起才能得出唯一解） 参考资料 声波的概念 https://www.bilibili.com/video/BV1Zq4y1u7Lq?from=search&amp;seid=6426463179542804956&amp;spm_id_from=333.337.0.0 基础乐谱🎼知识 https://www.lightnote.co/ 人是怎么感知声音频率高低的？ https://www.zhihu.com/question/307507978/answer/563839879 傅立叶变换 https://www.bilibili.com/video/BV1A4411Y7vj?spm_id_from=333.999.0.0 ","link":"https://jayying007.github.io/post/数字音频技术介绍/"},{"title":"IOS15导航栏透明的问题","content":"描述 当我写上以下代码时，导航栏看起来就是透明的 @interface ViewController () &lt;UITableViewDataSource&gt; @end @implementation ViewController - (void)viewWillAppear:(BOOL)animated { self.navigationController.navigationBar.backgroundColor = UIColor.redColor; } - (void)viewDidLoad { [super viewDidLoad]; self.title = @&quot;Title&quot;; UITableView *tableView = [[UITableView alloc] initWithFrame:self.view.bounds]; tableView.backgroundColor = UIColor.lightGrayColor; tableView.dataSource = self; [self.view addSubview:tableView]; } - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return 2; } - (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [[UITableViewCell alloc] init]; cell.textLabel.text = [NSString stringWithFormat:@&quot;%ld&quot;, indexPath.row]; return cell; } @end 只有当我滚动tableView时，导航栏才会出现。 解决方法 - (void)viewWillAppear:(BOOL)animated { if (@available(iOS 13.0, *)) { UINavigationBarAppearance *appearance = [[UINavigationBarAppearance alloc] init]; [appearance configureWithOpaqueBackground]; appearance.backgroundColor = UIColor.redColor; self.navigationController.navigationBar.standardAppearance = appearance; self.navigationController.navigationBar.scrollEdgeAppearance = appearance; } else { self.navigationController.navigationBar.backgroundColor = UIColor.redColor; } } 其他 还有一个比较常见的就是显示or隐藏导航栏底部的那条线 代码： - (void)viewWillAppear:(BOOL)animated { if (@available(iOS 13.0, *)) { UINavigationBarAppearance *appearance = [[UINavigationBarAppearance alloc] init]; [appearance configureWithOpaqueBackground]; appearance.backgroundColor = UIColor.whiteColor; appearance.shadowColor = UIColor.clearColor; // 隐藏线 self.navigationController.navigationBar.standardAppearance = appearance; self.navigationController.navigationBar.scrollEdgeAppearance = appearance; } else { self.navigationController.navigationBar.backgroundColor = UIColor.whiteColor; [self.navigationController.navigationBar setShadowImage:nil]; //隐藏线 } } ","link":"https://jayying007.github.io/post/IOS15导航栏透明的问题/"},{"title":"IOS中的hitTest和pointInside","content":"事件处理流程 1.当用户点击屏幕时，会产生一个触摸事件，系统会将该事件加入到一个由UIApplication管理的事件队列中 2.UIApplication会从事件队列中取出最前面的事件进行分发以便处理，通常，先发送事件给应用程序的主窗口(UIWindow) 3.主窗口会调用hitTest:withEvent:方法在视图(UIView)层次结构中找到一个最合适的UIView来处理触摸事件 (hitTest:withEvent:其实是UIView的一个方法，UIWindow继承自UIView，因此主窗口UIWindow也是属于视图的一种) 这个过程可以用下面的代码描述 @interface JJView : UIView @property (nonatomic) NSString *viewID; @end @implementation JJView - (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event { NSLog(@&quot;%@:%s&quot;, self.viewID, __func__); if ([self pointInside:point withEvent:event] == NO) { return nil; } NSArray *subviews = self.subviews; for (int i = (int)subviews.count - 1; i &gt;= 0; i--) { UIView *view = subviews[i]; CGPoint viewPoint = [view convertPoint:point fromView:self]; UIView *hitSubview = [view hitTest:viewPoint withEvent:event]; if (hitSubview) { return hitSubview; } } return self; } - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { NSLog(@&quot;%@:%s&quot;, self.viewID, __func__); return CGRectContainsPoint(self.bounds, point); } @end 应用场景 通过合理的重载在两个方法，可以实现一些特殊的效果。 1. 扩大点击区域 @interface JJView : UIView @property (nonatomic) UIEdgeInsets touchInsets; @end @implementation JJView - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { CGRect responsibleRect = CGRectMake(-self.touchInsets.left, -self.touchInsets.top, self.frame.size.width + self.touchInsets.left + self.touchInsets.right, self.frame.size.height + self.touchInsets.top + self.touchInsets.bottom); return CGRectContainsPoint(responsibleRect, point); } @end 2. 子View超出父View部分仍可响应 - (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event { for (UIView *view in self.subviews) { if (CGRectContainsPoint(view.frame, point)){ return YES; } } return NO; } ","link":"https://jayying007.github.io/post/IOS中的hitTest和pointInside/"},{"title":"IOS中使用HealthKit获取步数、运动记录等数据","content":"在IOS中想要获取步数等信息，需要借助HealthKit，其本质上是从手机的健康App上获取数据。 只要用户授权了，你的App就可以读取和写入数据到健康App中 框架导入 首先你需要引入HealthKit到你的项目中。 授权文案 另外需要在info.plist配置一下授权说明，否则请求授权时就会crash。 Apple提供了HKActivityRingView来绘制运动环，之前不知道，还自己画了一个😓 注意⚠️的问题 HealthKit在IOS13下有一个bug，会导致crash https://developer.apple.com/forums/thread/693289 获取授权状态应该在子线程做，因为其内部会wait semaphore，不然会导致卡顿 代码已同步Github https://github.com/jayying007/ios-kit/tree/master/healthkit HKActivityRingView的表示：在Apple自带的健身App中，数值是向下取整来表示的，但是环的绘制还是用原来的值（浮点数） 无法通过系统API确认用户是否同意or拒绝授权，只能知道之前是否出现过弹窗 ","link":"https://jayying007.github.io/post/IOS中使用HealthKit获取步数、运动记录等数据/"},{"title":"UISwitch在IOS12下的Bug","content":"重现方式 在UISwitch的ValueChange事件中，修改UISwitch的on属性。 示例代码 @interface ViewController () @property (nonatomic) UISwitch *oSwitch; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.view.backgroundColor = UIColor.whiteColor; _oSwitch = [[UISwitch alloc] initWithFrame:CGRectMake(50, 100, 100, 60)]; [self.view addSubview:_oSwitch]; [_oSwitch addTarget:self action:@selector(valueChange:) forControlEvents:UIControlEventValueChanged]; } - (void)valueChange:(UISwitch *)oSwitch { NSLog(@&quot;change&quot;); oSwitch.on = !oSwitch.on; } @end 输出结果 2021-12-01 20:21:31.674948+0800 demo-switch[56902:576481] change 2021-12-01 20:21:31.675095+0800 demo-switch[56902:576481] change 点击开关切换，可以看到valueChange方法被调用了两次！！ 解决方法 把UISwitch中on属性的修改放到下一个Runloop中 - (void)valueChange:(UISwitch *)oSwitch { NSLog(@&quot;change&quot;); dispatch_async(dispatch_get_main_queue(), ^{ oSwitch.on = !oSwitch.on; }); } ","link":"https://jayying007.github.io/post/UISwitch在IOS12下的Bug/"},{"title":"OC中的链式语法","content":"点语法 1.在OC中，访问对象的property时，可以使用点语法的方式访问 2.调用无参数的方法时，也可使用点语法。 最终效果 输入 person.say(@&quot;Hello, World!&quot;).walk(); 输出 这个人说：Hello, World! 绕了地球两圈 这在其他语言中是很容易实现的，比如C++和Java，其调用方法本身就是通过点语法的方式进行，只要返回值是self就行。 OC如何实现这种效果 答案是借助Block。 拿上面的代码进行拆分： person.say(@&quot;Hello, World!&quot;).walk(); 前半段person.say可以理解为调用了无参数的say方法，而后面还有小括号和参数(@&quot;Hello, World!&quot;)。那只要say方法返回一个Block，这个Block需要一个执行参数即可。相当于前半段代码执行了这个Block。 而后面还需要调用walk方法，则需要这个Block返回对象本身。 需要注意的是，后半段是.walk()而不是.walk，后者执行执行了walk方法，但却没有执行对应返回的Block。 代码示例 #import &lt;Foundation/Foundation.h&gt; @class Person; typedef Person* (^Sayback)(NSString *); typedef Person* (^Walkback)(void); @interface Person : NSObject - (Sayback)say; - (Walkback)walk; @end #import &quot;Person.h&quot; @implementation Person - (Sayback)say { return ^Person *(NSString *word) { NSLog(@&quot;这个人说：%@&quot;, word); return self; }; } - (Walkback)walk { return ^Person *() { NSLog(@&quot;绕了地球两圈&quot;); return self; }; } @end 总结 链式语法让代码写得更简洁了，但是其调用次数也翻倍了 原先是直接调用方法，现在变成调用方法会返回Block，然后再执行这个Block 在Java8中出现了流式编程Java Stream，可将代码写得很精致，如下面所示，也好奇🤔OC能否也实现这种效果 Stream.of(&quot;apple&quot;, &quot;banana&quot;, &quot;orange&quot;, &quot;waltermaleon&quot;, &quot;grape&quot;) .mapToInt(e -&gt; e.length()) //转成int .forEach(e -&gt; System.out.println(e)); Stream.of(1,2,3,1,2,5,6,7,8,0,0,1,2,3,1) .filter(e-&gt;e&gt;=5) //过滤小于5的 .forEach(e-&gt;System.out.println(e)); ","link":"https://jayying007.github.io/post/OC中的链式语法/"},{"title":"Objective-C中的block语法","content":"Objective-C中的block语法 前言 之前学习Obj-C的时候，看过《Objective-C高级编程》，是中文翻译版的，读起来总感觉少了些味道。 不过作者是日本的，原版日文我更看不懂，幸好英文版的翻译好了很多，而且英语六级也过了🐶，这次看得下去。Block的知识在第四章和第五章。 本篇文章大部分图片也是从里面摘过来的。 Block简介 简单回顾一下Block的用法 Block可以算是对C语言语法的一种扩展，借助结构体和函数指针的技术即可实现。如果你对函数指针比较熟悉，那你很容易理解Block。不过跟函数指针稍微有些区别，函数指针需要对应函数的函数名，但是Block不需要，它只要一个匿名函数即可。 废话不多说，直接看代码： int main() { (void)(^blk_t)(void) = ^void (void) { printf(&quot;Hello world.&quot;); }; } 这里的blk_t就是存放Block的变量，通过blk_t()就可以执行这个Block，输出Hello world。声明Block变量的方式跟声明函数指针有点像，看起来就是把*换成了^。Block的基本格式如下： 如果没有返回值，没有参数列表，则可以进一步省略。 Block内部可以使用外面的局部变量，当然也包括静态变量、全局变量等。但是这个使用的变量的值只是在Block创建那一刻复制的，后面修改是不会改变的，而且你也不能在Block内部对这个变量进行修改。 int main() { int val = 10; (void)(^blk_t)(void) = ^void (void) { printf(&quot;value is :%d&quot;, val); }; val = 2222; blk_t(); } 此时输出为value is 10 要想在Block内部修改这个变量，只需要在变量前加上__block即可，变成__block int val = 10;。或者还有一种方式是通过指针，就好比调用函数时的实参和形参，传的参数是指针就可修改到对应的数值。 int main() { int val = 10; int *p = &amp;val; (void)(^blk_t)(void) = ^void (void) { *p = 2222; }; printf(&quot;value is :%d&quot;, val); blk_t(); printf(&quot;value is :%d&quot;, val); } 指针的这种方式，只要你不在Block内部修改变量p的值就不会报错，至于修改变量p指向的内存，则无所谓。同理可得下面这种也是正确的： int main() { id array = [[NSMutableArray alloc] init]; (void)(^blk_t)(void) = ^void (void) { id obj = [[NSObject alloc] init]; [array addObject:obj]; }; blk_t(); } Block的实现原理 借助Clang，我们可以将OC的代码转换为C++代码，从而看到Block在C层面上是如何实现的。 clang -rewrite-objc filename.m 后面如果代码含有__weak，则需要补充多几个参数 clang -rewrite-objc -fobjc-arc -fobjc-runtime=ios-14.0.0 filename.m 第一组（使用局部变量，但是不使用__block） 源代码 #import &lt;Foundation/Foundation.h&gt; int main() { int val = 10; void (^blk)(void) = ^ { printf(&quot;val:%d&quot;, val); }; blk(); return 0; } clang转换后的代码（省略一些无关的，都是import带来的东西...） struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int val; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _val, int flags=0) : val(_val) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { int val = __cself-&gt;val; // bound by copy printf(&quot;val:%d&quot;, val); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)}; int main() { int val = 10; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, val)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); return 0; } 第一次看起来确实有点头疼，不过书中讲的也比较详细，多看几遍就好了。 看到结构体__main_block_impl_0，这就是Block在C层面下的面目了。里面有个字段val，通过构造函数传递过来的_val进行赋值。 而原本block的代码，可以看到被放到函数__main_block_func_0里面去了，而且里面的val也不是原先的局部变量的，就是结构体自己的变量而已。这也就解释了为什么局部变量的值改了，Block执行的输出确还是之前的，因为这已经是两个不同的变量了。 第二组（使用__block） 源代码 #import &lt;Foundation/Foundation.h&gt; int main() { __block int val = 10; void (^blk)(void) = ^ { val = 222; }; printf(&quot;val:%d&quot;, val); blk(); printf(&quot;val:%d&quot;, val); return 0; } clang转换后的代码 struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr; }; struct __Block_byref_val_0 { void *__isa; __Block_byref_val_0 *__forwarding; int __flags; int __size; int val; }; struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_val_0 *val; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_val_0 *_val, int flags=0) : val(_val-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_val_0 *val = __cself-&gt;val; // bound by ref (val-&gt;__forwarding-&gt;val) = 222; } static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;val, (void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/); } static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-&gt;val, 8/*BLOCK_FIELD_IS_BYREF*/); } static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*); } __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0}; int main() { __attribute__((__blocks__(byref))) __Block_byref_val_0 val = {(void*)0,(__Block_byref_val_0 *)&amp;val, 0, sizeof(__Block_byref_val_0), 10}; void (*blk)(void) = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_val_0 *)&amp;val, 570425344)); printf(&quot;val:%d&quot;, (val.__forwarding-&gt;val)); ((void (*)(__block_impl *))((__block_impl *)blk)-&gt;FuncPtr)((__block_impl *)blk); printf(&quot;val:%d&quot;, (val.__forwarding-&gt;val)); return 0; } 代码又复杂了一些，其实主要是多了一个结构体__Block_byref_val_0，细看这个结构体，你会发现它记录了之前局部变量的值。所以__block基本上就把变量包装成一个结构体了。 对val的访问就变成了val.__forwarding-&gt;val，为什么有这个__forwarding,这主要因为Block可以在栈、堆、全局上，具体细节看书。 关于Block内部对变量的读写 前面我们知道可通过添加__block实现，但也有一些情况是不需要的。 比如当你这个变量是全局变量、静态全局变量、静态局部变量，不需要在变量名前增加修饰符也可以读写。 前两个容易理解，因为Block最终还是转换成函数，在函数内部访问全局变量是OK的，Block结构体不用新增什么字段； 静态局部变量则多了些工作量，通过clang转换代码后，发现Block的结构体内部会有一个指针变量指向这个静态局部变量。 循环引用 前面我们在Block中用的都是一些基础数据类型，如果我们使用object的会怎样呢？ 答案是会造成循环引用。比如下面这种写法 我们看看Clang转换后的代码，其中带上了__strong标记，引用计数+1 在前面加上__block也是一样的，都是强引用 解决方法也比较简单，改为弱引用即可 补充一 实际开发中一般遇到的是下面这种情况，一个Object对象有一个属性Block，相互持有。 或者把self用__block修饰，形成下面这种循环引用。 这种比较有意思，你可以在Block内部特定时机将__block variable释放，从而解除循环引用，这种用法比较高级。 补充二 一般在Block前使用__weak就可以了，但是对于访问成员变量却行不通，而修改成员变量一般都是通过指针操作。 __weak typeof(self) weakSelf = self; blk = ^(id obj) { weakSelf.money = 100000; weakSelf-&gt;height = 222; }; 这里第二句weakSelf-&gt;height = 222;编译器会提示错误，因为weakSelf有可能变成nil，会导致非法的内存访问。 另一种修改成员变量的方法是通过__block的方式 也为了防止Block执行过程中self突然释放了，在Block中一般会先强引用一下self，而离开了Block作用域，强引用自然消失了； __weak typeof(self) weakSelf = self; blk = ^(id obj) { __strong typeof(self) strongSelf = weakSelf; strongSelf.money = 100000; strongSelf-&gt;height = 222; }; 不过上面这种也有一定概率crash，即有可能strongSelf是nil； 比如当Block是一个全局变量的时候，而Object生命周期先结束变成nil，此时再执行Block就会crash。如果Block是Object的一个属性或成员变量，也不会有这个问题。 另外，在开发中一般也不会去写这么长的weakSelf和strongSelf，我们是希望直接用self。(比如你灵机一动，想从其他地方copy一份代码直接放到Block，结果发现得一步步把self替换成strongSelf，过程相当痛苦😖) 这部分内容RAC有相关的实现，通过@weakify(self)和@strongify(self)。这里我简化了一下实现，代码如下： #define weakify(VAR) __weak typeof(VAR) _weak_ = VAR; #define strongify(VAR) __strong typeof(VAR) VAR = _weak_; //使用宏定义后的效果 weakify(self); blk = ^(id obj) { strongify(self); self.money = 100000; self-&gt;height = 222; }; ","link":"https://jayying007.github.io/post/Objective-C中的block语法/"},{"title":"ios播放动态图","content":"项目中偶尔会需要播放动态图片，比如一些动态的表情包。常见的动态图格式大家可能都知道Gif，但其实还有一个APNG格式也是动态的，这也是设计师给我设计稿时我才知道有这种格式的动态图。 问题 IOS自带的ImageView并不能播放动态图，它只会显示第一帧 ImageView有个方法setAnimationImages，确实能播放图片。但注意这里GIF和APNG都是单张图片，所以ImageView并不适用。 - (void)loadData { NSString *gifPath = [[NSBundle mainBundle] pathForResource:@&quot;1.gif&quot; ofType:nil]; self.gifData = [NSData dataWithContentsOfFile:gifPath]; NSString *apngPath = [[NSBundle mainBundle] pathForResource:@&quot;2.png&quot; ofType:nil]; self.apngData = [NSData dataWithContentsOfFile:apngPath]; } - (void)showWithImageView { UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 150, 100, 40)]; label.text = @&quot;UIImageView&quot;; [self.view addSubview:label]; UIImageView *gifImageView = [[UIImageView alloc] initWithFrame:CGRectMake(120, 100, 100, 100)]; gifImageView.image = [UIImage imageWithData:self.gifData]; [self.view addSubview:gifImageView]; UILabel *gifLabel = [[UILabel alloc] initWithFrame:CGRectMake(160, 200, 100, 40)]; gifLabel.text = @&quot;Gif&quot;; [self.view addSubview:gifLabel]; UIImageView *apngImageView = [[UIImageView alloc] initWithFrame:CGRectMake(240, 100, 100, 100)]; apngImageView.image = [UIImage imageWithData:self.apngData]; [self.view addSubview:apngImageView]; UILabel *apngLabel = [[UILabel alloc] initWithFrame:CGRectMake(280, 200, 100, 40)]; apngLabel.text = @&quot;Apng&quot;; [self.view addSubview:apngLabel]; } 方法一 使用WebView展示，基本上只要你的浏览器能播放动态图，使用WebView也就能显示了，但好像无法改变图片大小 - (void)showWithWebView { UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 270, 100, 40)]; label.text = @&quot;WKWebView&quot;; [self.view addSubview:label]; WKWebView *gifWebView = [[WKWebView alloc] initWithFrame:CGRectMake(120, 270, 100, 100)]; [gifWebView loadData:self.gifData MIMEType:@&quot;image/gif&quot; characterEncodingName:@&quot;UTF-8&quot; baseURL:nil]; [self.view addSubview:gifWebView]; UILabel *gifLabel = [[UILabel alloc] initWithFrame:CGRectMake(160, 320, 100, 40)]; gifLabel.text = @&quot;Gif&quot;; [self.view addSubview:gifLabel]; WKWebView *apngWebView = [[WKWebView alloc] initWithFrame:CGRectMake(240, 270, 100, 100)]; [apngWebView loadData:self.apngData MIMEType:@&quot;image/png&quot; characterEncodingName:@&quot;UTF-8&quot; baseURL:nil]; [self.view addSubview:apngWebView]; UILabel *apngLabel = [[UILabel alloc] initWithFrame:CGRectMake(280, 320, 100, 40)]; apngLabel.text = @&quot;Apng&quot;; [self.view addSubview:apngLabel]; } 方法二 借助ImageIO的API接口，我们自己封装一个AnimateImageView。这里我们既能调整图片大小，也能通过参数控制播放速度等，非常灵活。 AnimateImageView.h // // AnimateImageView.h // demo-image // // Created by jieying zhuang on 2021/9/5. // #import &lt;UIKit/UIKit.h&gt; NS_ASSUME_NONNULL_BEGIN @interface AnimateImageView : UIImageView - (instancetype)initWithData:(NSData *)data; - (void)startPlay; //回到第一帧 - (void)stopPlay; @end NS_ASSUME_NONNULL_END AnimateImageView.m // // AnimateImageView.m // demo-image // // Created by jieying zhuang on 2021/9/5. // #import &quot;AnimateImageView.h&quot; #import &lt;ImageIO/CGImageAnimation.h&gt; /** 可以用来显示Gif，APng这类动态图； 限制：IOS13.0及以上 */ @interface AnimateImageView () @property (nonatomic, strong) UIImage *firstFrameImage; @property (nonatomic, strong) NSData *data; @property (nonatomic) NSUInteger beginningFrameIndex; //从哪一帧开始 @property (nonatomic) CGFloat delayPerFrame; //每一帧播放时长 @property (nonatomic) NSUInteger loopCount; //循环次数 @property (nonatomic) BOOL stopPlayback; //是否停止播放 @end @implementation AnimateImageView - (instancetype)initWithData:(NSData *)data { if ([super init]) { self.firstFrameImage = [UIImage imageWithData:data]; self.data = data; self.beginningFrameIndex = 0; self.delayPerFrame = 0.04f; self.loopCount = 0; self.stopPlayback = NO; self.image = self.firstFrameImage; } return self; } - (void)startPlay { self.stopPlayback = NO; [self startAnimateImage]; } - (void)stopPlay { self.stopPlayback = YES; } #pragma mark - Private - (void)startAnimateImage { __weak typeof(self) weakSelf = self; NSDictionary *options = [self animationOptionsDictionary]; if (@available(iOS 13.0, *)) { CGAnimateImageDataWithBlock((CFDataRef)self.data, (CFDictionaryRef)options, ^(size_t index, CGImageRef _Nonnull image, bool *_Nonnull stop) { *stop = weakSelf.stopPlayback; if (weakSelf.stopPlayback) { weakSelf.image = weakSelf.firstFrameImage; } else { weakSelf.image = [UIImage imageWithCGImage:image]; } }); } } - (NSDictionary *)animationOptionsDictionary { NSMutableDictionary&lt;NSString *, NSNumber *&gt; *options = [NSMutableDictionary new]; if (@available(iOS 13.0, *)) { [options addEntriesFromDictionary:@{ (NSString *)kCGImageAnimationStartIndex : @(self.beginningFrameIndex), (NSString *)kCGImageAnimationDelayTime : @(self.delayPerFrame) }]; if (self.loopCount &gt; 0) { options[(NSString *)kCGImageAnimationLoopCount] = @(self.loopCount); } } return [options copy]; } @end 使用方法 - (void)showAnimateImageView { UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(10, 450, 150, 40)]; label.text = @&quot;AnimateImageView&quot;; [self.view addSubview:label]; AnimateImageView *gifImageView = [[AnimateImageView alloc] initWithData:self.gifData]; gifImageView.frame = CGRectMake(160, 400, 100, 100); [gifImageView startPlay]; [self.view addSubview:gifImageView]; UILabel *gifLabel = [[UILabel alloc] initWithFrame:CGRectMake(200, 520, 100, 40)]; gifLabel.text = @&quot;Gif&quot;; [self.view addSubview:gifLabel]; AnimateImageView *apngImageView = [[AnimateImageView alloc] initWithData:self.apngData]; apngImageView.frame = CGRectMake(270, 400, 100, 100); [apngImageView startPlay]; [self.view addSubview:apngImageView]; UILabel *apngLabel = [[UILabel alloc] initWithFrame:CGRectMake(310, 520, 100, 40)]; apngLabel.text = @&quot;Apng&quot;; [self.view addSubview:apngLabel]; } 参考资料 https://www.swiftjectivec.com/animating-images-using-image-io/ ","link":"https://jayying007.github.io/post/ios播放动态图/"},{"title":"ios自定义转场动画","content":"最近工作需要对转场时导航栏做样式变化，在网上找到一个对于转场来说不错的教程。 原文链接：https://www.jianshu.com/p/28b9523d70a9 以下大部分来自转载的内容： iOS7.0后苹果提供了自定义转场动画的API，利用这些API我们可以改变 push和pop（navigation非模态），present和dismiss（模态），标签切换（tabbar）的默认转场动画。 主要涉及的API 1、UIViewControllerAnimatedTransitioning：转场动画协议，实现此协议定义转场的动画行为。 // 定义转场动画的时间 - (NSTimeInterval)transitionDuration:(nullable id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; // 定义转场动画的行为 - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext; 2、 UIViewControllerContextTransitioning：转场动画上下文，这个协议定义了转场动画具体参数，控制转场动画的状态，这个协议一般由系统实现，在转场发生时提供给我们使用。 From和To：转场是两个视图控制器（ViewController）的行为，由一个视图控制器切换到另一个视图控制器，原先呈现的视图控制器叫FromViewController，将要呈现的视图控制器叫ToViewController，那么FromViewController的view叫做FromView，ToViewController的view叫做ToView。 对应push和pop来说是两个不同的转场，它们的From和To在两个转场中使相互调换的。 containerView:转场动画完成都是在containerView里面。 3、UIViewControllerInteractiveTransitioning：转场的交互协议，用来控制转场动画的状态或进度。 //设置转场进度, 取值范围 [0..1] - (void)updateInteractiveTransition:(CGFloat)percentComplete; //完成转场，呈现to - (void)finishInteractiveTransition; //取消转场，呈现from - (void)cancelInteractiveTransition; 4、UIPercentDrivenInteractiveTransition：官方提供的实现UIViewControllerInteractiveTransitioning协议的类，可以直接使用。 上面简单的介绍了转场动画涉及的API，这一节主要通过导航控制器的push和pop转场动画来介绍这些自定义转场动画的流程。 push转场动画 1、准备工作： 带有导航控制器的ViewController类，要push到的下一级控制器SecondViewController类。 2、在类HSPushAnimation中实现UIViewControllerAnimatedTransitioning协议，定义push转场动画行为。 @interface HSPushAnimation : NSObject &lt;UIViewControllerAnimatedTransitioning&gt; @end @implementation HSPushAnimation //设置转场动画的时长 - (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ return 2.f; } - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ //from UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; //to UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIView* toView = nil; UIView* fromView = nil; //UITransitionContextFromViewKey和UITransitionContextToViewKey定义在iOS8.0以后的SDK中，所以在iOS8.0以下SDK中将toViewController和fromViewController的view设置给toView和fromView //iOS8.0 之前和之后view的层次结构发生变化，所以iOS8.0以后UITransitionContextFromViewKey获得view并不是fromViewController的view if ([transitionContext respondsToSelector:@selector(viewForKey:)]) { fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; toView = [transitionContext viewForKey:UITransitionContextToViewKey]; } else { fromView = fromViewController.view; toView = toViewController.view; } //这个非常重要，将toView加入到containerView中 [[transitionContext containerView] addSubview:toView]; CGFloat width = [UIScreen mainScreen].bounds.size.width; CGFloat height = [UIScreen mainScreen].bounds.size.height; toView.frame = CGRectMake(width, 0, width, height); [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ toView.frame = CGRectMake(0, 0, width, height); } completion:^(BOOL finished) { [transitionContext completeTransition:YES]; }]; } @end 上面代码定义了一个非常简单的动画，toView从左到右覆盖fromView，和系统默认动画一样，只是时间设置的比较长。 转场动画所有要呈现的元素都要放在containerView中，fromView默认已经在containerView中了。 3、指定push要使用的转场动画行为：由于要自定义转场动画所以我们需要指定转场动画行为。push转场的动画行为是由UINavigationControllerDelegate协议指定，所以我们在ViewController设置导航控制器的Delegate： - (void)viewDidAppear:(BOOL)animated{ [super viewDidAppear:animated]; self.navigationController.delegate = self; } 实现以下协议，指定动画类： - (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC{ if (operation == UINavigationControllerOperationPush) { return [[HSPushAnimation alloc] init]; } return nil; } 这个方法可以分别指定push和pop的动画类，这里我们只定义push动画，所以只要指定UINavigationControllerOperationPush时的动画行为即可。 这样push转场动画就完成了，效果图如下： pop转场动画 1、pop转场动画和push转场动画类似，在类HSPopAnimation中实现UIViewControllerAnimatedTransitioning协议。 @implementation HSPopAnimation - (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ return 0.5; } - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIView* toView = nil; UIView* fromView = nil; if ([transitionContext respondsToSelector:@selector(viewForKey:)]) { fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; toView = [transitionContext viewForKey:UITransitionContextToViewKey]; } else { fromView = fromViewController.view; toView = toViewController.view; } //将toView加到fromView的下面，非常重要！！！ [[transitionContext containerView] insertSubview:toView belowSubview:fromView]; CGFloat width = [UIScreen mainScreen].bounds.size.width; CGFloat height = [UIScreen mainScreen].bounds.size.height; fromView.frame = CGRectMake(0, 0, width, height); [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ fromView.frame = CGRectMake(width, 0, width, height); } completion:^(BOOL finished) { [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; }]; } @end 这里pop动画基本和push动画是相反的过程，当然你也可以指定别的方式的动画。 这里from、to和push动画里面的from、to值已经互换了，所以如果将push和pop动画写在一起的话，要特别注意，不过建议将push和pop动画分别定义到不同的类中，方便管理。 2、在SecondViewControlle类中设置导航控制器的Delegate，并实现以下协议： - (id&lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController animationControllerForOperation:(UINavigationControllerOperation)operation fromViewController:(UIViewController *)fromVC toViewController:(UIViewController *)toVC{ if (operation == UINavigationControllerOperationPop) { return [[HSPopAnimation alloc] init]; } return nil; } pop转场动画就完成了，效果图如下： 可交互转场动画 先来看看可交互转场动画效果 可交互转场动画的实现需要实现UIViewControllerInteractiveTransitioning协议，幸好官方给我们提供了UIPercentDrivenInteractiveTransition类可以直接使用，你也可以继承UIPercentDrivenInteractiveTransition来使用。 UIViewControllerInteractiveTransitioning协议的功能主要是控制转场动画的状态，即动画完成的百分比，所以只有在转场中才有用。 比如我们通过[self.navigationController popViewControllerAnimated:YES]触发pop转场动画，然后在转场动画结束之前通过- (void)updateInteractiveTransition:(CGFloat)percentComplete更改转场动画的完成的百分比，那么转场动画将由实现UIViewControllerInteractiveTransitioning的类接管，而不是由定时器管理，之后就可以随意设置动画状态了。 交互动画往往配合手势操作，手势操作产生一序列百分比数通过updateInteractiveTransition方法实时更新转场动画状态。 1、现在添加为SecondViewControlle的view添加手势： //添加pan手势 UIPanGestureRecognizer * pan = [[UIPanGestureRecognizer alloc] init]; [pan addTarget:self action:@selector(panGestureRecognizerAction:)]; [self.view addGestureRecognizer:pan]; 2、触发转场动画，通过手势产生百分比数值，更新转场动画状态： - (void)panGestureRecognizerAction:(UIPanGestureRecognizer *)pan{ //产生百分比 CGFloat process = [pan translationInView:self.view].x / ([UIScreen mainScreen].bounds.size.width); process = MIN(1.0,(MAX(0.0, process))); if (pan.state == UIGestureRecognizerStateBegan) { self.interactiveTransition = [UIPercentDrivenInteractiveTransition new]; //触发pop转场动画 [self.navigationController popViewControllerAnimated:YES]; }else if (pan.state == UIGestureRecognizerStateChanged){ [self.interactiveTransition updateInteractiveTransition:process]; }else if (pan.state == UIGestureRecognizerStateEnded || pan.state == UIGestureRecognizerStateCancelled){ if (process &gt; 0.5) { [ self.interactiveTransition finishInteractiveTransition]; }else{ [ self.interactiveTransition cancelInteractiveTransition]; } self.interactiveTransition = nil; } } 手势开始状态：手势开始时创建UIPercentDrivenInteractiveTransition对象，通过popViewControllerAnimated方法触发转场动画。 手势变化状态：通过计算得到的百分比实时更新转场动画的状态。 手势取消或者结束状态：根据完成的百分比决定是否完成转场或者取消转场。 3、开始转场动画时，就需要指定一个实现UIViewControllerInteractiveTransitioning协议的对象来控制转场动画的状态，否则转场动画状态由定时器管理。在SecondViewControlle类中，我们通过UINavigationControllerDelegate协议将interactiveTransition对象传给UIKit： - (void)viewDidAppear:(BOOL)animated{ [super viewDidAppear:animated]; self.navigationController.delegate = self; } - (id&lt;UIViewControllerInteractiveTransitioning&gt;)navigationController:(UINavigationController *)navigationController interactionControllerForAnimationController:(id&lt;UIViewControllerAnimatedTransitioning&gt;)animationController{ if ([animationController isKindOfClass:[HSPopAnimation class]]) { return self.interactiveTransition; } return nil; } 以上步骤就将pop的可交互转场动画完成了。 push和pop转场动画基本流程 Note： 动画的状态和转场的状态是不一样的，动画完成后，不代表转场完成，所以我们要在动画的completion里面决定是否完成转场：[transitionContext completeTransition:!transitionContext.transitionWasCancelled]; 转场是一个过程，所有的动画都在containerView里面完成。 不需要交互的转场interactionControllerForAnimationController方法一定要返回nil 补充 熟悉了上面的自定义流程后，我们可以很方便的做出我们想要的动画效果。 场景一：从有导航栏vc进入全屏vc，返回的时候导航栏位置固定，逐渐显示； 解法：这个比较简单，在我们前面的基础之上，设置导航栏的隐藏和显示即可。 在SecondViewController添加以下代码： - (void)viewWillAppear:(BOOL)animated { [self.navigationController setNavigationBarHidden:YES animated:animated]; } - (void)viewWillDisappear:(BOOL)animated { [self.navigationController setNavigationBarHidden:NO animated:animated]; } 场景二：从有导航栏vc进入全屏vc，返回的时候导航栏应该跟在toView一起拉过来。 解法：延用场景一的代码，然后在前面的HSPopAnimation的animateTransition方法中补充navigationBar的动画即可。 给一下完整的代码： @implementation HSPopAnimation - (NSTimeInterval)transitionDuration:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ return 0.5; } - (void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext{ UIViewController *toViewController = [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey]; UIViewController *fromViewController = [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey]; UIView* toView = nil; UIView* fromView = nil; if ([transitionContext respondsToSelector:@selector(viewForKey:)]) { fromView = [transitionContext viewForKey:UITransitionContextFromViewKey]; toView = [transitionContext viewForKey:UITransitionContextToViewKey]; } else { fromView = fromViewController.view; toView = toViewController.view; } //将toView加到fromView的下面，非常重要！！！ [[transitionContext containerView] insertSubview:toView belowSubview:fromView]; CGFloat width = [UIScreen mainScreen].bounds.size.width; CGFloat height = [UIScreen mainScreen].bounds.size.height; fromView.frame = CGRectMake(0, 0, width, height); //设置导航栏初始位置 UINavigationBar *navBar = toViewController.navigationController.navigationBar; CGRect navRect = navBar.frame; navBar.frame = CGRectMake(-width, navRect.origin.y, navRect.size.width, navRect.size.height); [UIView animateWithDuration:[self transitionDuration:transitionContext] animations:^{ fromView.frame = CGRectMake(width, 0, width, height); navBar.frame = CGRectMake(0, navRect.origin.y, navRect.size.width, navRect.size.height); } completion:^(BOOL finished) { [transitionContext completeTransition:!transitionContext.transitionWasCancelled]; }]; } @end 细心的同学会发现这里导航栏的透明度是逐渐变化的，要是想固定透明度100%，改一下方法即可 [self.navigationController setNavigationBarHidden:NO animated:NO]; 其他资料 https://tech.meituan.com/2018/10/25/navigation-transition-solution-and-best-practice-in-meituan.html ","link":"https://jayying007.github.io/post/ios自定义转场动画/"},{"title":"NSTimer的一些理解&RunLoop简介","content":"RunLoop The purpose of a run loop is to keep your thread busy when there is work to do and put your thread to sleep when there is none. The app frameworks automatically set up and run the run loop on the main thread as part of the application startup process. You must be sure to add one or more input sources, timers, or run-loop observers to any modes you create for them to be useful. 错误做法： dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [runLoop run]; [NSTimer scheduledTimerWithTimeInterval:3 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@&quot;in other thread.&quot;); }]; }); 正确做法： dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{ NSRunLoop *runLoop = [NSRunLoop currentRunLoop]; [NSTimer scheduledTimerWithTimeInterval:3 repeats:YES block:^(NSTimer * _Nonnull timer) { NSLog(@&quot;in other thread.&quot;); }]; [runLoop run]; }); RunLoop有多种Modes，在某一时刻只会运行在一种Mode下，处理这个Mode下对应的sources。 一般情况下，项目中都不需要我们去使用RunLoop，因为主线程的已经默认开启了。子线程的话，除非你需要Timer、performSelector这类需要运行在RunLoop上的东西时才开启。 NSTimer 从RunLoop的特性我们知道，一般情况下NSTimer运行在NSDefaultRunLoopMode模式，当scrollview滑动时，RunLoop是运行在UITrackingRunLoopMode模式下的，此时NSTimer就不工作了，到了指定时间也不会触发事件。 If a timer is not in the mode currently being monitored by the run loop, it does not fire until you run the run loop in one of the timer’s supported modes. NSTimer并不是实时的，如果当前RunLoop有任务在执行，Timer将等任务结束再处理。如果你是一个重复的Timer，在5秒、10秒、15秒这些时间点触发，第一次因为延迟而在7秒的时候才执行，那么下次执行时间还是10秒。 If the firing time is delayed so much that it misses one or more of the scheduled firing times, the timer is fired only once for the missed time period. 比如下面每隔十秒执行的Timer： 49秒的时候delay，直到53秒执行； 59秒的时候delay，直到08秒执行； 39秒、49秒的时候delay，也只在56秒执行一次。 延迟后要不要执行，可以通过设置tolerance去做 注意点 Run loops maintain strong references to their timers, so you don’t have to maintain your own strong reference to a timer after you have added it to a run loop RunLoop强引用Timer，Timer强引用Target，所以Timer存在的话，Target就不会消亡。通过invalidate方法可以从RunLoop中移除Timer。不过如果你把invalidate写在target的dealloc里面，那就是循环引用了 关于后台运行 理论上，app进入后台，短暂待一会就进入挂起状态。你可以在项目中设置一个重复的Timer去验证。 所以问题是，如果你想在几个小时后（比如你的App是类似闹钟之类的东西）执行某些代码逻辑？ 这里有一些方法供参考： 设置本地通知。通知是由IOS管理的，所以不用担心App被kill掉，只要时间一到，IOS就会触发通知 类似于后台播放音乐、定位、VOIP这些（这些可能需要申请权限，而且滥用的话苹果审核估计也不通过），可以后台播放静音文件（伪装你在播放音乐，实际是做它用），这样你的App就能一直运行了。。 如果不是要精确的时间的话，可以在下次App启动的时候去做个时间检查，过了时间点的就可以执行相关的逻辑。 参考资料 https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW1 https://blog.csdn.net/totogo2010/article/details/107321490?spm=1001.2014.3001.5501 https://www.jianshu.com/p/11fae16ab622 https://developer.apple.com/documentation/foundation/nstimer ios应用程序状态变迁 ","link":"https://jayying007.github.io/post/对NSTimer的一些理解/"},{"title":"分享一道算法设计题","content":"题目 有一个函数rand()能生成1-65536之间的整数，利用这个函数，让30万人中有5万人中奖，要求保证公平（即每个人的中奖几率一样）。 | | | | | | | | | 思路 首先解决如何做到30万人抽出5万人，还保证公平。 假设能实现一个函数randX()，他能返回1-30万之间的整数，那么我可以制定一个策略，从随机到的数向后取5万个。如下图所示 当后面不足5万个时，从头部补一些 这种方式真的能保证公平吗，让我们来验证一下 每个人的中奖概率为 5万/30万 = 1/6 上面的这种方法，红色部分共有30万种可能（初始位置从1-30万），而每一个位置，比如5万这个位置，红色部分共有5万种可能会覆盖到这个数，所以这个位置被选到的概率也是 5万/30万 = 1/6 现在问题转为如何设计一个randX()，使其返回1-30万之间的整数，且公平 一个错误方式是将rand() * (300000/65536)，这种方式虽然能得到1-300000之间的整数，但是有些数却永远取不到。 rand()=1时，rand()*(300000/65536)=4.5776,那么无论如何你就取不到1，2，3了 那么该如何解决呢？一种方法是分区间 比如把30万划分为5个一样大的区别，每个区间只有6万 我们先随机取1-5之间的数，从而确定在那个区间取。 一个区间只有6万，所以我们可以用rand()来取1-6万之间的整数了，最后加上区间起始位置的数就可以了。 这样就没问题了吗？ 其实如果选择不慎，还是不公平的。 比如一个能生成1-10随机数的函数rand，用它来生成1-4的随机数，如果写成rand%4+1，那结果就是错的。 我们可以列出所有计算的可能情况 生成1: 1 5 9 生成2: 2 6 10 生成3: 3 7 生成4: 4 8 可见生成不同随机数的概率其实是不一样的，生成1的概率是十分之三，生成4的概率是十分之二。 要实现一个公平的随机数生成器，需要保证生成的最大数为原来随机器最大数的因数。比如1-10对应能制造生成1-2和1-5两种随机器，且保证公平。 而针对上面这种情况，我们能做的是拒绝采样（reject sampling），当得到的数为9或10时，让它重新生成一个随机数直到满足条件。 对于本文的题，65536的因数都是2的指数次幂，而30万不是，所以也只能采用拒绝采样的方法。 ","link":"https://jayying007.github.io/post/分享一道算法设计题/"},{"title":"基于消息表的分布式事务","content":"在分布式数据库中，通过避免强一致性可以带来伸缩性的巨大提升。 简介 随着你公司Web应用的发展，数据库容易陷入瓶颈。通常有两种方法解决这个问题，垂直扩展和水平扩展。 垂直扩展通过提升硬件性能，但一般比较昂贵。 水平扩展是本文主要讨论的方法，相比垂直扩展要复杂一些。 水平扩展的方式通常也有两种：按模块切分，数据表做切片（Sharding） 按模块切分的方式，将 Users, products, and transactions切分到不同的数据库。不同模块通过设计合适的外键进行关联访问。 每个模块可以根据具体容量再进行切分 ACID与BASE 我们知道，在单个数据库下，是可以实现ACID的。而在跨多个数据库的情况下，一般是通过2PC实现。2PC保证了强一致性，而根据CAP理论可以得知，其可用性则无法完全实现。 那如果我们想要可用性，不要求强一致性呢？可以试试BASE。 如果说ACID是悲观的，要求每个操作都严格一致，那么BASE则是乐观的，允许流动（flux）的状态。 BASE的高可用并不是保证每个用户请求都被执行。比如有5台数据库服务器，当有一台服务器宕机了，那么大约只有20%的用户访问不了，这种情况下我们仍然认为系统是可用的。 下面我们以一个例子演示从单机到多机的变化。 例子 假设我们有以下数据表User和Transaction，它们存放在同一个数据库中。每当有一件商品卖出时，向Transaction表插入一条数据，然后更新买家和卖家的user表。 上面这个过程可以通过下面的SQL事务表示 当我们按模块划分后，user和transaction位于不同的数据库服务器上，此时再执行则变成了两个独立的事务。 这种情况下，若事务1执行成功，事务2执行失败，就出现了数据不一致的情况。怎么解决这种问题呢？这里就引入了我们本文的主角，消息表。 实现消息表的方法可能有很多，但不管怎样，我们需要将消息的执行也划归到我们的事务内。引入消息表后，我们的SQL语句会变成下面这样。 可以创建一个后台进程，查询消息表，然后根据消息内容更新user表。 不过上述的代码其实有问题，因为消息表是和transaction表一起的，跟user表在不同的数据库服务器上，如果按照上面那种方法，一个事务中有update消息表和user表，又回到了使用2PC。 如何解决这个问题？这里要先引入一个概念，幂等性。 如果一个操作执行一次或几次的结果都是一样的，那么它就是幂等的。如果一个操作是幂等的，那么可以实现：即使操作失败了，我们可以重试直到成功，而重试不会影响最终结果。 我们上面的这个例子则不支持幂等，每次操作都会改变购买量或销售量。怎么解决呢？可以在user表所在数据库服务器上再加一个表 然后将SQL语句改为下面这种 从上面的SQL语句中可以看出，message被移到了事务外面，这样使得只有在事务操作成功的时候才将其从消息表中移除。 当事务执行成功，在移除消息表之前宕机，重启之后又重新消费这条消息。而事务中有对已消费信息的判断，从而解决了重复消费的问题。这样保证了数据在最后能达到一致性。 参考资料 https://queue.acm.org/detail.cfm?id=1394128 ","link":"https://jayying007.github.io/post/基于消息表的分布式事务/"},{"title":"简述垃圾回收算法","content":"概念 垃圾回收(Garbage Collection),简称GC,主要是对那些已经分配的空间进行回收利用,实现再分配. 比如下面的Java代码 public void test() { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); System.out.println(list); } 在这个函数中,我创建了一个ArrayList对象,Java则在内存堆上为其分配空间.但是一旦出了这个函数,我们就再也访问不到这块空间了,如果不进行回收,那么内存堆的这个位置就浪费了. 所以GC要完成的主要有两件事: 找到内存中的垃圾 回收这部分垃圾,以便之后可以再分配 关于对象在堆上的布局 一般一个对象在堆中存储两部分信息,一部分是对象的元数据,比如对象的大小,hashcode的值以及用来标识垃圾回收的信息等.另一部分就是对象的具体数据.这部分主要分两种,如果是基本数据类型,那么这个位置存的就是它的值.如果不是,那么这个位置存放的是指向具体内存地址的指针. 如何找到内存中的垃圾 这里采用可达性分析,首先我们会将一些对象作为根,这些对象我们把它标记为可达的,然后由这些根所能指向的其他对象,我们也标记为可达...这样一直传递下去,到最后,我们可以遍历整个堆,然后把那些不可达的对象给回收掉. 哪些对象可以作为根呢 ---&gt; 调用栈、寄存器以及全局变量 不过,这些根可能还有潜在的问题. 怎么判断这个值是指针的地址还是一个基本数据类型呢? 就概率上讲,数值刚好位于堆地址范围内,且刚好是对象头的地址,情况还是比较少的. 我们可以将错就错,不过在这种情况下,可能一个本该回收的对象就被我们列为根了. 当存在貌似指针的非指针时，保守式GC会把被引用的对象错误识别为活动对象。如果这个对象存在大量的子对象，那么它们一律都会被看成活动对象 要严格区别指针与非指针,需要语言处理程序的一些支持.这一块不作展开. GC算法评价指标 吞吐量 如堆的大小为HEAP_SIZE,GC总共花费的时间为（A+B+C),则吞吐量为HEAP_SIZE/（A+B+C）。 最大暂停时间 最大暂停时间指的是“因执行GC而暂停执行mutator的最长时间”,比如下图指的就是B. 如果暂停时间太长,就会出现Stop-The-World 堆使用效率 不同的GC算法,会在堆中对象的对象头存放一些信息,大小不一,或者会将堆做划分. 访问的局部性 我们知道计算机是有高速缓存这么个东西.一般而言,具有引用关系的对象之间通常很可能存在连续访问的情况。所以如果在堆中这两个对象存放位置连续,那当读取第一个对象时,后面的对象也跟着被读进了缓存,后续访问的速度就加快了. GC算法介绍 标记清除算法 这个其实在前面也有提到,从根集合出发,将能访问到的对象打上标记,然后遍历堆,将没有标记的对象清除.伪代码描述如下: mark_sweep() { //标记阶段 for(r : $roots) { mark(*r) } //清除阶段 sweeping = $heap_start while(sweeping &lt; $heap_end) if(sweeping.mark == TRUE) sweeping.mark = FALSE else sweeping.next = $free_list $free_list = sweeping sweeping += sweeping.size } //标记函数 mark(obj) { if(obj.mark == FALSE) { obj.mark = TRUE for(child : children(obj)) mark(*child) } } 这种方式不会挪动对象在堆中的位置,但是容易产生内存碎片.关于回收后的内存如何分配使用,可以找更相关的资料.比如参考malloc库的实现,在&lt;&lt;深入理解计算机系统&gt;&gt;一书中也有所涉及. 引用计数法 顾名思义,在对象头记录有多少个引用了这个对象.当计数变为0的时候,我们就可以立即对这部分内存进行回收. 它的最大暂停时间短,但是存在多个无用对象循环引用无法释放内存的问题. Python的GC采用了引用计数法,可以去了解它如何解决循环引用的 标记复制算法 这种算法把堆划分为两部分,每次分配对象的时候只使用其中一半.当标记过程结束后,把存活的对象全都挪到堆的另一半中. 这种的好处是避免了内存碎片,因为每次都有一整块的空闲空间用于分配对象.但显然堆的使用效率降低了 注意 在这种算法中,由于挪动了对象,所以原先指向这些对象的指针,要做一个映射,使其访问到新的内存位置. 解决方法可以采用句柄的方式间接处理对象. (采用指向指针的指针也可以) 通过引入句柄,当我们移动对象的时候,只需要修改句柄里的指针,而不用更新根的值. 标记整理算法 这种算法可以理解为先执行了标记清除算法,然后把存活的对象都挪到一起,这样空闲的空间就是连续的了. 同样的,由于移动了对象,所以指针的访问也要做些修改. 分代回收 在对象头部分多了对象的存活年龄,据此划分了新生代,老年代对象.在堆中也是划分存储. 根据经验显示,新生代的对象存活率较低,所以这部分会有大量对象回收.对这部分采取标记复制算法收益比较好; 而针对老年代对象,则采用标记清除算法. 当需要GC时,优先从新生代入手. 当我们对新生代进行GC时,如果有老年代的指向新生代的引用,怎么办? 如果遍历老年代去标记,那其实又跟遍历整个堆没区别了. 所以这里引入了记录集和写入屏障 记录集上面保存了老年代对象的指针. 它是在我们更新对象指针的时候,通过写入屏障的方式加入的. write_barrier(obj, field, new_obj) { if(obj &gt;= $old_start &amp;&amp; new_obj &lt; $old_start &amp;&amp; obj.remembered == FALSE) $rs[$rs_index] = obj $rs_index++ obj.remembered = TRUE *field = new_obj } 如上述伪代码那样,当老年代对象有某个属性指向新生代对象时,将其加入记录集中. 这样的好处是当新生代对象的内存位置移动时,能够知道要更新哪个老年代对象的指针 增量式垃圾回收 上面提到的GC都有一个问题,它们在进行垃圾回收时会阻塞主线程,直到垃圾回收结束. 这里主要讲一种增量GC的算法,它的GC要分好几个阶段完成,这样保证最大暂停时间变小. 三色标记算法 这是Edsger W. Dijkstra等人提出的三色标记算法（Tri-color marking）,它将每个对象都标记了一个颜色: 白色：还未搜索过的对象 灰色：正在搜索的对象 黑色：搜索完成的对象 GC开始运行前所有的对象都是白色。GC一开始运行，所有从根能到达的对象都会被标记，然后被堆到栈里。GC只是发现了这样的对象，但还没有搜索完它们，所以这些对象就成了灰色对象。灰色对象会被依次从栈中取出，其子对象也会被涂成灰色。当其所有的子对象都被涂成灰色时，对象就会被涂成黑色。当GC结束时已经不存在灰色对象了，活动对象全部为黑色，垃圾则为白色。 它可以分为三个阶段: 根查找阶段,标记阶段,清除阶段 根查找阶段把能直接从根引用的对象涂成灰色。 标记阶段查找灰色对象，将其子对象也涂成灰色，查找结束后将灰色对象涂成黑色。 清除阶段则查找堆，将白色对象连接到空闲链表，将黑色对象变回白色. // 在标记,清除阶段中,其都是增量式的,即每次只标记或清除一定数量的对象后切回主线程. 这里还有几个需要注意的地方. 问题1 如图,当A标记完所有子对象后,自己变黑. 此时切换回主线程,然后主线程的代码做了个操作,将B--C之间的引用删掉,然后加了A--C的引用. 这时再回来GC的时候,由于A已经黑了,所以不会再对其子对象做标记, 这样就会错过对象C, 这样会误回收对象!! 解决这个问题的办法同样使用写入屏障, 在添加A指向C的引用时, 如果C是白色的,就将其标黑. write_barrier(obj, field, newobj) { if(newobj.mark == FALSE) { newobj.mark = TRUE push(newobj, $mark_stack) } *field = newobj } 问题2 如图,当GC开始清除阶段时,它会把没有标黑的对象给清除掉. 如果这时切换回主线程,而我们又要分配新的对象时就要注意了, 如果分配的新对象位置在$sweeping的右边, 那我们要把新分配的对象给标成黑色的,以防被误清除. 参考资料 &lt;&lt;垃圾回收的算法与实现&gt;&gt; ----- [日]中村成洋，[日]相川光 ","link":"https://jayying007.github.io/post/简述垃圾回收算法/"},{"title":"自己手动生成二维码","content":"虽然生成二维码不是什么难事，毕竟有那么多轮子，工作中你就是调一下SDK，并不会去关心它具体怎么实现的（比如zxing算一个，不想麻烦的可以用这个）。但是两三行调用别人的代码就完事感觉没什么意思，其实还是想折腾。 如果对二维码的原理不熟悉，可以参考我转载的这篇博客https://blog.csdn.net/qq_17190121/article/details/104715136 博主写得很清楚了，看一两遍然后就懂了 找不到官方文档，貌似ISO要收费。。然后就在百度文库中找了中文版的https://wenku.baidu.com/view/ef77275f312b3169a451a4a4.html?pn=50 自我感觉代码写得一般，但逻辑很清晰，基本步骤如图 其实上面这个图是在写代码出现bug时想到的一个办法，嗯...，还挺好看的 因为目的是用手机扫码，所以二维码的规格不用特别大，一般只需要存一个网站的地址即可，微信/支付宝扫到二维码时会自动跳转到这个网址。 我这里用的规格 版本 纠错等级 编码方式 6 H Byte Mode 参考文档位置 初始化数据 # 相关信息 self.version = 6 # H纠错等级的指示码，版本6的字节数，划分数据块数，每块数据数，每块纠错数 self.relate_info = {'err_code': '10', 'total_bytes': 172, 'number_of_block': 4, 'per_block_data': 15, 'per_block_err': 28} # 对齐图案中心点位置 self.align_pos = 34 self.size = 21 + (self.version - 1) * 4 # 0表示白，1表示黑，2表示未使用 self.pattern = np.ones([self.size, self.size], dtype=int) * 2 self.data = data # 格式：{'000':[[1,0,0,1]...[0,1,1,0],'001':...} self.masking_pattern = None self.masking_coding = None self.draw = True 绘制定位图案 版本确定了，位置也就确定了 def get_position_pattern(self): # 画好一个定位图案 position_pattern = np.ones([7, 7], dtype=int) for i in range(1, 6): for j in range(1, 6): if i == 1 or i == 5: position_pattern[i][j] = 0 continue if j == 1 or j == 5: position_pattern[i][j] = 0 continue # 放在三个位置 for i in range(0, 7): for j in range(0, 7): self.pattern[i][j] = position_pattern[i][j] self.pattern[i][j + self.size - 7] = position_pattern[i][j] self.pattern[i + self.size - 7][j] = position_pattern[i][j] if self.draw: self.dynamic_draw() 绘制定位图案白边 def get_position_round_pattern(self): for i in range(0, 8): self.pattern[i][7] = 0 self.pattern[7][i] = 0 self.pattern[i][self.size - 8] = 0 self.pattern[self.size - 8][i] = 0 self.pattern[i + self.size - 8][7] = 0 self.pattern[7][i + self.size - 8] = 0 if self.draw: self.dynamic_draw() 绘制对齐图案 def get_alignment_pattern(self): # 画好一个对齐图案 alignment_pattern = np.ones([5, 5], dtype=int) for i in range(1, 4): for j in range(1, 4): if i == 1 or i == 3: alignment_pattern[i][j] = 0 continue if j == 1 or j == 3: alignment_pattern[i][j] = 0 continue # 只放置在一个位置 for i in range(0, 5): for j in range(0, 5): self.pattern[i + self.align_pos - 2][j + self.align_pos - 2] = alignment_pattern[i][j] if self.draw: self.dynamic_draw() 绘制时序图案 def get_timing_pattern(self): fill_black = True for i in range(8, self.size - 7): if fill_black: self.pattern[6][i] = 1 self.pattern[i][6] = 1 else: self.pattern[6][i] = 0 self.pattern[i][6] = 0 fill_black = not fill_black if self.draw: self.dynamic_draw() 绘制临时的格式图案 主要是为了占坑，让后面填充数据的操作更简单 def get_tmp_format_pattern(self): # 右上角0-7 for i in range(0, 8): self.pattern[8][self.size - 1 - i] = 0 # 左下角8-14 for i in range(0, 7): self.pattern[self.size - 7 + i][8] = 0 # 固定黑点 self.pattern[self.size - 8][8] = 0 # 左上角部分 for i in range(0, 6): self.pattern[i][8] = 0 for i in range(0, 6): self.pattern[8][5 - i] = 0 # 位置是固定的 self.pattern[7][8] = 0 self.pattern[8][8] = 0 self.pattern[8][7] = 0 绘制版本图案 这个版本刚好不用，版本7以上才需要 def get_version_pattern(self): # version7及以上才有 pass 获取掩膜图案 这个版本是长这样的 看看如何生成这么奇怪的形状 def get_masking_area(self): masking_area = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if self.pattern[i][j] == 2: masking_area[i][j] = 1 return masking_area def get_masking_pattern(self): # 八个模板 masking_array = {} masking_area = self.get_masking_area() ########## code = &quot;000&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if (i + j) % 2 == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking ########## code = &quot;001&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if i % 2 == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking ########## code = &quot;010&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if j % 3 == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking ########## code = &quot;011&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if (i + j) % 3 == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking ########## code = &quot;100&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): # 这里有一点坑,不转为int会变成float+float if (int(i / 2) + int(j / 3)) % 2 == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking ########## code = &quot;101&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if ((i * j) % 2 + (i * j) % 3) == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking ########## code = &quot;110&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if ((i * j) % 2 + (i * j) % 3) % 2 == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking ########## code = &quot;111&quot; masking = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if ((i * j) % 3 + (i + j) % 2) % 2 == 0: masking[i][j] = masking_area[i][j] masking_array[code] = masking self.masking_pattern = masking_array 填充最初的数据 def fill_data(self): # 右下角开始填充，先右后左，蛇形走位 x = self.size - 1 y = self.size - 1 pos_right = True direct = 1 # 0向下 1向上 index = 0 data = _rsEncode(self.data, self.relate_info['per_block_data'], self.relate_info['number_of_block'], self.relate_info['per_block_err']) remainder = 7 while index &lt; len(data) + remainder: if self.pattern[x][y] == 2: if index &lt; len(data): self.pattern[x][y] = int(data[index]) # 把剩下7个空白补上--版本6剩下7个空白位置 else: self.pattern[x][y] = 0 index = index + 1 if pos_right: y = y - 1 else: x = x + (-1) ** direct y = y + 1 pos_right = not pos_right # 向上飞出天了 if x &lt; 0: direct = 0 x = 0 y = y - 2 # 刚好碰到时序线,这个的位置固定y为6，要左移一格 if y == 6: y = y - 1 # 向下钻出地了 if x &gt; 40: direct = 1 x = 40 y = y - 2 if self.draw: self.dynamic_draw() 与所有掩膜做异或，选择处罚最低的 这里的评价一开始代码写的很晕，因为中文文档的表述不是很清楚。所以我找了英文的来看，它下面有详细的解释，理解起来容易很多 def find_best_masking_and_set(self): coding = '' score = 0 for key in self.masking_pattern.keys(): mask_score = self.get_mask_score(self.masking_pattern[key], key) print(key, mask_score) if coding == '': coding = key score = mask_score else: if score &gt; mask_score: score = mask_score coding = key self.masking_coding = coding # set # 可以针对去调整评价算法 masking_pattern = self.masking_pattern[coding] # 执行异或操作 for i in range(self.size): for j in range(self.size): self.pattern[i][j] = masking_pattern[i][j] ^ self.pattern[i][j] if self.draw: self.dynamic_draw() self.get_format_pattern() def get_mask_score(self, masking_pattern, key): array = np.zeros([self.size, self.size], dtype=int) self.masking_coding = key self.get_format_pattern() # 执行异或操作 for i in range(self.size): for j in range(self.size): array[i][j] = masking_pattern[i][j] ^ self.pattern[i][j] n1 = 0 n2 = 0 n3 = 0 n4 = 0 # 横竖存黑白相间次数的数组 row_interval = [] col_interval = [] # 横竖连续5个以上颜色相同，分数：个数-2 i = 0 while i &lt; self.size: j = 0 interval = [] while j &lt; self.size: times = 0 k = j while k &lt; self.size and array[i][k] == array[i][j]: k = k + 1 times = times + 1 interval.append(times) if times &gt;= 5: n1 = n1 + times - 2 j = k i = i + 1 row_interval.append(interval) i = 0 while i &lt; self.size: j = 0 interval = [] while j &lt; self.size: times = 0 k = j while k &lt; self.size and array[k][i] == array[j][i]: k = k + 1 times = times + 1 interval.append(times) if times &gt;= 5: n1 = n1 + times - 2 j = k i = i + 1 col_interval.append(interval) # 存在2X2颜色相同的块 for i in range(self.size - 1): for j in range(self.size - 1): if array[i][j] == array[i + 1][j] and array[i][j] == array[i][j + 1]: if array[i][j] == array[i + 1][j + 1]: n2 = n2 + 3 # 横竖出现1:1:3:1:1 的黑白黑白黑，且前面或后面有4个以上白 for i in range(self.size): if array[i][0] == 1: first_dark = True else: first_dark = False # bug warning for j in range(1, len(row_interval[i])-5): if row_interval[i][j] == row_interval[i][j+1] and row_interval[i][j]*3 == row_interval[i][j+2]: if row_interval[i][j] == row_interval[i][j+3] and row_interval[i][j] == row_interval[i][j+4]: if row_interval[i][j-1] &gt;= 4 and not first_dark: n3 = n3 + 40 first_dark = not first_dark continue if row_interval[i][j+5] &gt;= 4 and not first_dark: n3 = n3 + 40 first_dark = not first_dark continue for i in range(self.size): if array[0][i] == 1: first_dark = True else: first_dark = False # bug warning for j in range(1, len(col_interval[i])-5): if col_interval[i][j] == col_interval[i][j+1] and col_interval[i][j]*3 == col_interval[i][j+2]: if col_interval[i][j] == col_interval[i][j+3] and col_interval[i][j] == col_interval[i][j+4]: if col_interval[i][j-1] &gt;= 4 and not first_dark: n3 = n3 + 40 first_dark = not first_dark continue if col_interval[i][j+5] &gt;= 4 and not first_dark: n3 = n3 + 40 first_dark = not first_dark continue # 黑色块的数量 dark_num = array.sum() dark_rate = dark_num * 100 / (self.size * self.size) n4 = n4 + int(math.fabs(dark_rate - 50) / 5) * 10 return n1 + n2 + n3 + n4 def get_format_pattern(self): code = int(self.relate_info['err_code'] + self.masking_coding, 2) format_code = '{:015b}'.format(_fmtEncode(code)) # 默认高位在前，反转一下 format_code = format_code[::-1] # 右上角0-7 for i in range(0, 8): self.pattern[8][self.size - 1 - i] = int(format_code[i]) # 左下角8-14 for i in range(0, 7): self.pattern[self.size - 7 + i][8] = int(format_code[i + 8]) # 固定黑点 self.pattern[self.size - 8][8] = 1 # 左上角部分 for i in range(0, 6): self.pattern[i][8] = int(format_code[i]) self.pattern[8][5 - i] = int(format_code[9 + i]) # 位置是固定的 self.pattern[7][8] = int(format_code[6]) self.pattern[8][8] = int(format_code[7]) self.pattern[8][7] = int(format_code[8]) 最后调用画图，看看自己做的二维码 def dynamic_draw(self): self.show() plt.pause(0.001) plt.clf() def show(self): pic = np.zeros([self.size, self.size], dtype=int) for i in range(self.size): for j in range(self.size): if self.pattern[i][j] == 1: pic[i][j] = 0 elif self.pattern[i][j] == 0: pic[i][j] = 255 else: pic[i][j] = 200 plt.imshow(pic, cmap=&quot;gray&quot;) plt.axis('off') plt.show() logo是我后期加上去的。。。 关于其中涉及到的两种编码 编数据的用到的里德-所罗门码：这里用了第三方库，虽然网上也能找到源代码，但有几十行，我就不添加了，直接第三方工具，一两行代码搞定 编格式用到的BCH码：代码有点少，所以用了源码 from reedsolo import RSCodec def _fmtEncode(fmt): &quot;&quot;&quot;Encode the 15-bit format code using BCH code.&quot;&quot;&quot; g = 0x537 code = fmt &lt;&lt; 10 for i in range(4, -1, -1): if code &amp; (1 &lt;&lt; (i + 10)): code ^= g &lt;&lt; i return ((fmt &lt;&lt; 10) ^ code) ^ 0b101010000010010 def _rsEncode(data, per_block_data, number_of_block, per_block_err): # Byte mode prefix 0100. bitstring = '0100' # Character count in 8 binary bits. bitstring += '{:08b}'.format(len(data)) # Encode every character in ISO-8859-1 in 8 binary bits. for c in data: bitstring += '{:08b}'.format(ord(c.encode('iso-8859-1'))) # Terminator 0000. bitstring += '0000' res = list() # Convert string to byte numbers. while bitstring: res.append(int(bitstring[:8], 2)) bitstring = bitstring[8:] total_data_length = per_block_data * number_of_block # Add padding pattern. while len(res) &lt; total_data_length: res.append(int('11101100', 2)) res.append(int('00010001', 2)) # Slice to 60 bytes for V6-H. res = res[:total_data_length] ecc = RSCodec(per_block_err) blocks = [] for i in range(number_of_block): block = ecc.encode(res[:per_block_data]) blocks.append(block) res = res[per_block_data:] # 先拼接数据，再拼接纠错编码 final_res = '' # 如果使用其他版本，可能不同数据块长度不同，请注意，这里四个数据块长度都是43 for i in range(per_block_data): for j in range(4): final_res = final_res + '{:08b}'.format(blocks[j][i]) for i in range(per_block_data, per_block_data+per_block_err): for j in range(4): final_res = final_res + '{:08b}'.format(blocks[j][i]) return final_res 注意：BCH码最后写回字符串时的第一个字符是二进制的高位，所以要反转一下 数据进行编码时，最终数据 = 4位编码格式 + 字符长度(这里刚好是8位) + 原数据的二进制 + 4位结束符 分块时，将最终数据分成若干份，再各自进行里德-所罗门码的编码，然后再按规定顺序重新组合排列 总结 代码：https://github.com/jayying007/QR_Code 前两天一窍不通，只觉得二维码挺有趣的，有点像密码学，到今天才大致理解其原理 后期两种纠错编码可以去了解一下 后期可以进一步优化，如添加logo，更改形状和颜色等，只要能识别就可以 其实这只是第一步，后面还有两步：拍照时定位到二维码并做预处理，将二维码还原为原始信息 中间有遇到很难理解的部分，也想过放弃（那会要准备实习，得疯狂补知识），但好在坚持了下来，花费了两天多时间我觉得值。 ","link":"https://jayying007.github.io/post/自己手动生成二维码/"},{"title":"快速幂","content":"​ 今天介绍一个在中低难度算法竞赛中经常碰到的算法---快速幂，于此相匹配的还有一个叫矩阵快速幂的东西。不过这篇文章只介绍快速幂，矩阵快速幂只是把两个数的乘法换成两个矩阵的乘法而已。 快速幂，顾名思义，就是快速求解某一个数的指数次方结果为多少。 普通求解 如让你求2^5次方，你可以很快计算出结果为2*2*2*2*2=32。 这种方式在计算机中可以使用pow函数解决，即pow（2,5）=32。引入头文件cmath就行了，当然你也可以手写。 pow函数的实现方式大致如下 typedef long long ll; ll pow(ll a,ll b,ll c) { ll d=1; while(b--){ d=d*a%c; } return d; } 不难看出，这种计算方式的速度是由b决定的，即时间复杂度为O（b），而如果b很大的，那就超时了啊！ 快速幂 下面就进入本节的主要内容，用快速幂求解，这其实是对二进制的巧妙使用。 讲一个例子，现在要求311，按上述方法需要计算11次，但快速幂可以将求311简化为(38)*(32)*(3^1)，这样就只计算了3次，其实总共比较了4次，往下看就懂了。 来一波分析： 将指数11转化为二进制，即00...001011（32位，前面的0我就省略不写了，太多容易看乱） 从右到左开始，32位的01串我们在下面给它们一个数值标识，从3^1开始，以平方的方式不断递增，如下面的表格所示（注意只给出最后边的6位，int类型总共应该有32位） 0 0 1 0 1 1 3^32 3^16 3^8 3^4 3^2 3^1 其实下面的指数也可以有另外一种方式理解，即当前位置的1表示十进制的哪个数，指数就是哪个。 所以下面的操作就很简单了，311=3(8+2+1)，为什么要拆成这几个数呢，因为他们就是11转成二进制后，对应的1的位置数值的表示啊（上面的表格），而这些位置的1代表的数加起来就是11. 那么计算的思路就是，读取11的二进制数，若该位置为1，就乘上该位置所代表的数，若为0则不作处理。 时间复杂度从O(N)降到了O(logN) 具体方法：将11与1做按位与位运算，若结果为1，说明11二进制最后的数为1，所以乘上。 然后下一步我们让11做右移位运算，即将32个01集体往右移动1位，这时最左侧会补上0，而最右侧的1已经不见了。相当于继续比较下一位，若当前数值为0，即二进制32个都为0，说明已经没有1了，就可以结束循环。 具体的代码实现 #include &lt;iostream&gt; using namespace std; typedef long long ll; ll quickPow(ll a,ll b,ll c) { ll d=1; while(b){ if(b&amp;1){ d=d*a%c; } a=a*a%c;//更新当前位置代表的数 b=b&gt;&gt;1;//右移1位 } return d; } int main() { cout&lt;&lt;&quot;10的1亿次方mod3的结果为: &quot;&lt;&lt;quickPow(10,1e9,3); return 0; } 矩阵快速幂 这里放一下矩阵快速幂的模板 typedef long long ll; const int mod=1e9+7; const int MaxN=105;//矩阵大小 struct Mat{ ll m[MaxN][MaxN]; }ans,a;//结果与输入矩阵 Mat Mul(Mat a,Mat b,int n){ Mat c; memset(c.m,0,sizeof(c.m)); for(int i=1;i&lt;=n;i++) for(int j=1;j&lt;=n;j++) for(int k=1;k&lt;=n;k++) c.m[i][j]=(c.m[i][j]+(a.m[i][k]*b.m[k][j])%mod)%mod; return c; } Mat _power(Mat a,ll b,int n){ for(int i=1;i&lt;=n;i++) ans.m[i][i]=1; while(b){ if(b&amp;1) ans=Mul(ans,a,n); a=Mul(a,a,n); b&gt;&gt;=1; } return ans; } ","link":"https://jayying007.github.io/post/快速幂/"},{"title":"字典树","content":" 字典树一般用于字符串的匹配，当数量多的时候效率还是挺明显的。 这里以一道洛谷的题为例子，https://www.luogu.org/problem/P2580 题目的大致意思时，先给你n个字符串，然后再给你m个字符串，求这m个字符串是否在n个字符串中出现过或是否重复出现了。 若采用朴素一对一的比较方式，那时间复杂度就是O(n X m X ‘字符串长度’)，所以还是算了。 解决的方法便是利用字典树，将n个字符串搭建成一个字典树。 什么是字典树？？？？比如字符串（ab,ac,b,bca,bcd）构成的字典树如下 红色标记的结点即该结点为某一字符串的结束结点，注意字典树的根结点不存任何字符 构建完字典树后，后面的操作就简单了。待查询的m个字符串依次从根节点开始查询，当前结点存在该字符，则更新当前位置到该字符所在结点，否则就证明查询不到。到最后一个字符匹配且该结点是结束结点，说明查询成功。 下面是题目的代码 #include&lt;iostream&gt; using namespace std; int n,m,cnt; string s; struct node { int vis[26]; int state;//0 普通节点 1 结束节点 2 结束且已访问 }tried[500010]; void Build_tree(string s) { int len=s.length(); int now=0; for(int i=0;i&lt;len;i++){ if(tried[now].vis[s[i]-'a']==0){ tried[now].vis[s[i]-'a']=++cnt; } now=tried[now].vis[s[i]-'a']; } tried[now].state=1; } void Query_str(string s) { int len=s.length(); int now=0; for(int i=0;i&lt;len;i++){ if(tried[now].vis[s[i]-'a']){ now=tried[now].vis[s[i]-'a']; if(i==len-1&amp;&amp;tried[now].state==1){ cout&lt;&lt;&quot;OK&quot;&lt;&lt;endl; tried[now].state=2; } else if(i==len-1&amp;&amp;tried[now].state==2){ cout&lt;&lt;&quot;REPEAT&quot;&lt;&lt;endl; } } else{ cout&lt;&lt;&quot;WRONG&quot;&lt;&lt;endl; break; } } } int main() { cin&gt;&gt;n; for(int i=0;i&lt;n;i++){ cin&gt;&gt;s; Build_tree(s); } cin&gt;&gt;m; for(int i=0;i&lt;m;i++){ cin&gt;&gt;s; Query_str(s); } return 0; } ","link":"https://jayying007.github.io/post/字典树/"},{"title":"部署Tensorflow模型到服务器-方法二","content":"环境 python 3.8.3 tensorflow 2.4.0 制作测试模型 注意: tensorflow版本1和版本2的接口不同, 我这里套用原来的代码, 修改部分需要兼容的代码.比如 tf.placeholder() --&gt; tf.compat.v1.placeholder()。如果你用的是版本1则不用修改 import tensorflow as tf import numpy as np import os # 文件夹不存在时,会报utf-8解析错误 if not os.path.exists('./model'): os.mkdir('./model') tf.compat.v1.disable_eager_execution() x = tf.compat.v1.placeholder(tf.float32, name='inputX') feed = np.random.rand(100) y = 2 * x + 1 w = tf.Variable(0.) b = tf.Variable(0.) y_ = tf.add(tf.multiply(w, x), b, name='outputY') loss = tf.reduce_mean(tf.square(y - y_)) optimizer = tf.compat.v1.train.GradientDescentOptimizer(0.2) train = optimizer.minimize(loss) init = tf.compat.v1.global_variables_initializer() with tf.compat.v1.Session() as sess: sess.run(init) for i in range(200): sess.run(train, feed_dict={x: feed}) if i % 5 == 0: print(i, sess.run([w, b])) constant_graph = tf.compat.v1.graph_util.convert_variables_to_constants(sess, sess.graph_def, ['outputY']) with tf.compat.v1.gfile.FastGFile('./model/linear.pb', mode='wb') as f: f.write(constant_graph.SerializeToString()) 部署上线 这里使用python的web服务器框架Flask，很容易上手的，而且Pycharm在创建项目时就能选择。 这里直接贴代码 app.py import tensorflow as tf from flask import Flask from flask import request app = Flask(__name__) with tf.compat.v1.gfile.FastGFile('./model/linear.pb', 'rb') as f: graph_def = tf.compat.v1.GraphDef() graph_def.ParseFromString(f.read()) tf.import_graph_def(graph_def, name='') sess = tf.compat.v1.Session() output = sess.graph.get_tensor_by_name('outputY:0') @app.route('/predict', methods=[&quot;GET&quot;]) def testPredict(): inputX = request.args.get(&quot;inputX&quot;) return str(sess.run(output, feed_dict={'inputX:0': inputX})) if __name__ == '__main__': app.run() 验证结果 程序启动后，默认监听的是5000端口，我们用浏览器访问 http://localhost:5000/predict?inputX=2，可以看到结果 完结撒花❀❀❀ ","link":"https://jayying007.github.io/post/部署Tensorflow模型到服务器-方法二/"},{"title":"部署Tensorflow模型到服务器--方法一","content":"基本思路：利用tensorflow官方提供的tensorflow serving进行部署，同时，为了免去环境配置等麻烦操作，可借助docker容器。 一、服务器环境选择 首先肯定要去租一个服务器，例如阿里云。一开始选了window server2012，结果很坑，装不了docker。上网想查解决方法，发现别人也遇到过这个问题。 了解的原因大概是：docker需要在linux的环境下运行。但通过在window server2012下使用vitural box运行linux虚拟机的办法不行，因为这样会造成二次虚拟（官方解释：阿里云给的轻量应用服务器是运行在虚拟机上的，所以不能再开虚拟机）。 不过网上一些大佬好像也给出了骚操作，但总之太过麻烦，不想去折腾，就没去尝试。 正当我觉得凉凉，想重新买linux服务器的时候，才发现阿里云的控制台上可以重新更改系统镜像，于是很愉快地换成了ubuntu18.04. 二、Ubuntu下docker容器的安装 前提条件：Docker 要求 Ubuntu 系统的内核版本高于 3.10 ，通过 uname -r 命令查看你当前的内核版本。 接下来就是在linux终端敲命令了： 1.获取docker安装包 wget -qO- https://get.docker.com/ | sh 完成后会有一段提示 If you would like to use Docker as a non-root user, you should now consider adding your user to the &quot;docker&quot; group with something like: sudo usermod -aG docker runoob Remember that you will have to log out and back in for this to take effect! 一般嫌麻烦的话，以后执行docker命令都在root下进行就可以了 2.运行docker容器 sudo service docker start 3.测试hello-world程序 docker run hello-world 第一次应该会失败，因为容器里还没有这个项目，所以docker会去下载，第二次运行就可以了。 三、模型的部署 1.拉取带tensorflow serving的docker镜像 docker pull tensorflow/serving 2.先来测试一下官方例子 cd /root/software/ git clone https://github.com/tensorflow/serving 将GitHub上的TensorFlow-serving拷贝下来，里面已经有一些模型，我们通过部署一个简单的模型上docker来观察结果 docker run -p 8501:8501 \\ --mount type=bind,\\ source=/root/software/serving/tensorflow_serving/servables/tensorflow/testdata/saved_model_half_plus_two_cpu,\\ target=/models/half_plus_two \\ -e MODEL_NAME=half_plus_two -t tensorflow/serving &amp; 运行成功后，我们写一个Python的代码测试 import requests import json pdata={&quot;instances&quot;:[1,2,3]} param=json.dumps(pdata) res=requests.post('http://localhost:8501/v1/models/half_plus_two:predict',data=param) print(res.text) 可以看到res返回的结果，对应的是我们输入的1,2,3，之后我们就利用这种方式传递图片或其他数据过去 { &quot;predictions&quot;: [2.5, 3.0, 3.5 ] } 结果分析： 启动docker的时候，开启了8501端口，后面url通过该端口进行访问 参数source表示你模型存放的文件夹，如果你去找这个文件夹，你会发现里面模型存放的格式有些特别，后面我们要部署模型时也需要先转为这种类型 model_name是docker上模型的名称，在url上也可以看到 target是存放在docker上的路径 下面就开始部署我们自己的模型了 4.部署自己模型 刚才第三步说过，要将模型导出为特殊的类型（有一个variables文件夹，同目录下一个pb模型，这个pb模型和之前的还不大一样）。 首先需要我们训练完模型后一个正常的checkpoint，转换的方法可以参考下面的做法 import tensorflow as tf import numpy as np x = tf.placeholder(tf.float32, name='input_x') feed = np.random.rand(100) y = x + 1 w = tf.Variable(0.) b = tf.Variable(0.) y_ = tf.add(tf.multiply(w, x), b) loss = tf.reduce_mean(tf.square(y-y_)) optimizer = tf.train.GradientDescentOptimizer(0.2) train = optimizer.minimize(loss) init = tf.global_variables_initializer() saver = tf.train.Saver() with tf.Session() as sess: sess.run(init) for i in range(200): sess.run(train, feed_dict={x: feed}) if i % 5 == 0: print(i, sess.run([w,b])) saver.save(sess, './linear/linear.ckpt') with tf.Session() as sess2: sess2.run(init) saver.restore(sess2, './linear/linear.ckpt') # 将训练好的模型保存在modelName下，版本为1，当然你的版本可以随便写 builder = tf.saved_model.builder.SavedModelBuilder(&quot;./modelName/1&quot;) inputs = { # 注意，这里是你预测模型的时候需要传的参数，调用模型的时候，传参必须和这里一致 # 这里的input_x就是模型里面定义的输入placeholder &quot;input_x&quot;: tf.saved_model.utils.build_tensor_info(x) } outputs = { &quot;output_y&quot;: tf.saved_model.utils.build_tensor_info(y), } prediction_signature = tf.saved_model.signature_def_utils.build_signature_def( inputs=inputs, outputs=outputs, method_name=tf.saved_model.signature_constants.PREDICT_METHOD_NAME ) builder.add_meta_graph_and_variables( sess2, [tf.saved_model.tag_constants.SERVING], {tf.saved_model.signature_constants.DEFAULT_SERVING_SIGNATURE_DEF_KEY: prediction_signature} ) builder.save() 之后仿照样例模型，用docker运行这个模型就可以了，端口号、路径和模型名称什么的自定义即可，不冲突就行。 docker run -p 8502:8501 \\ --mount type=bind,\\source=/root/software/serving/tensorflow_serving/servables/tensorflow/testdata/face/face2,\\target=/models/face2 \\ -e MODEL_NAME=face2 -t tensorflow/serving &amp; 一段测试代码，跟上面的有一点类似，具体什么参数看自己的模型 import requests import numpy as np import json # json格式序列调整 class NumpyEncoder(json.JSONEncoder): def default(self, obj): if isinstance(obj, np.ndarray): return obj.tolist() return json.JSONEncoder.default(self, obj) feature=np.array(range(128)) param = { &quot;instances&quot;:[ #每一个大括号是一次请求，里面是每次请求的参数 { &quot;in&quot;:feature } ] } param = json.dumps(param, cls=NumpyEncoder) res = requests.post(&quot;http://localhost:8502/v1/models/face2:predict&quot;, data=param) # 根据自己设定的返回数据读取 # softmax = json.loads(res2.text)[&quot;predictions&quot;][0] 至此，大功告成。 PS：如果有多个模型需要部署，只需要修改本地端口号即可，不需要修改docker的端口号。（就是docker run命令的时候，只改第一个8501，不需要改第二个8501） ","link":"https://jayying007.github.io/post/部署Tensorflow模型到服务器-方法一/"},{"title":"k-means算法","content":"简介 据说是机器学习中最简单的一种方法，属于非监督学习这一类。通俗一点讲，给机器一堆数据，告诉机器要分成多少种类别，然后机器就根据算法进行各种操作。 实现原理 需要我们确定变量k，即最终 的数据会有几种类别。 总共有k个中心坐标，一开始可以随机赋值，通过计算目标点坐标与所有中心坐标的距离，将其归类在距离较近的类别中。 之后根据类别中的目标点计算平均值重新得到中心坐标，再重复上面的工作。 距离公式 常用的距离公式如欧式距离，马氏距离，曼哈顿距离。 借助科学计算库可以帮我们节省一些时间。 from scipy.spatial.distance import pdist pdist(np.array([dot[j], center[k]]), 'euclidean')#欧氏距离 小小示例 import numpy as np import matplotlib.pyplot as plt from scipy.spatial.distance import pdist dimension = 2 # 生成多个随机点，范围[0,10) dot_num = 100 dot = np.random.rand(dot_num,dimension)*10 # 生成多个随机中心点，范围[0,10) center_num = 4 center = np.random.rand(center_num,dimension)*10 # 循环迭代 times = 50 for i in range(times): plt.clf() # 数据映射 belong = np.zeros([dot_num]) # 计算随机点与中心点的距离，将其归属于距离近的中心点 dist = np.zeros([dot_num,center_num]) for j in range(dot_num): for k in range(center_num): dist[j][k] = pdist(np.array([dot[j], center[k]]), 'euclidean') belong[j] = np.argmax(dist[j]) # 绘图 for j in range(center_num): temp_dot = [] for k in range(dot_num): if(belong[k] == j): temp_dot.append(dot[k]) # 根据随机点求取均值，得出新的中心点 if(len(temp_dot) != 0): temp_dot = np.array(temp_dot) plt.scatter(temp_dot[:,0],temp_dot[:,1]) for k in range(dimension): center[j][k] = np.sum(temp_dot[:,k])/len(temp_dot) else: center[j] = np.zeros([dimension]) # print(center) plt.pause(1) # 满足迭代次数或中心点不再改变，结束命令 说明 上述代码为动态实时更新画板内容，其中的关键代码如下 import matplotlib.pyplot as plt for i in range(5): # 清除画布 plt.clf() # 绘制散点 plt.scatter(temp_dot[:,0],temp_dot[:,1]) # 暂停间隔 plt.pause(1) ","link":"https://jayying007.github.io/post/k-means算法/"},{"title":"二分查找","content":"概念 二分查找，又称折半查找。顾名思义，就是在一堆有序排列的元素中查找某一指定数值。返回数值对应的下标或-1（查不到）。 场景模拟 看其他文章都是千篇一律的猜数字，我们换一换风格，来猜一猜价格吧。这不是一样的吗？ 比如说现在让你猜一件商品的价格，已知商品的价格在1-1000元之间，且为整数，现在让你尽快猜中商品的价格，你要怎么做呢？（你每猜一个价格，都能得知这个价格与正确价格相比是相同的，还是小了或大了） 鲁莽的方法：从1元开始猜到1000元，总会猜到的。运气好的话，价格刚好是1元，猜一次就中了。运气不好的话，价格是1000元，要猜1000次才能猜中。 这种方法其实没有充分利用猜价格得到的反馈信息，即从1元开始猜到1000元的过程中，你得到的反馈只有正确或者小了，绝对不会出现大了。 睿智的方法：既然价格在1元到1000元之间，那我就猜500元，即（1+1000）/2。这时可能的反馈信息分别有 比正确价格小：这样我们就知道商品的价格不在1元到500元之间，而是在501元到1000元之间。 与正确价格相同：即我们猜中了，所以就直接返回这个结果就可以了。 比正确价格大：所以商品价格不在500元到1000元之间，而是在1元到499元之间。 **不难看出，只经过一次猜测，可能猜中或者把猜测范围缩小一半。后面用同样的方式猜测，则又可以将猜测范围缩小一半。**这个不就是递归吗？虽然用循环也可以做 用二分查找的时间复杂度为O（logN） 代码模板 #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; void binarySearch(vector&lt;int&gt; arr,int aim) { /* * 参数说明：arr即查找的容器序列，aim为需要查找的元素 * 要求：arr容器需保证元素升序 */ int left=0,right=arr.size()-1,mid=(left+right)/2; while(left&lt;=right) { if(arr[mid]&lt;aim){ left=mid+1; } else if(arr[mid]==aim){ cout&lt;&lt;&quot;找到了&quot;; return; } else if(arr[mid]&gt;aim){ right=mid-1; } mid=(left+right)/2; } cout&lt;&lt;&quot;找不到&quot;; return; } int main() { vector&lt;int&gt; arr; for(int i=1;i&lt;=10;i++){ arr.push_back(i*2); } binarySearch(arr,7); return 0; } ","link":"https://jayying007.github.io/post/二分查找/"},{"title":"KVO&KVOController及其原理","content":"KVO介绍 KVO全名Key Value Observing，是一种通知机制，使得当某个Object的Property发生变化时，能够得到通知，它基于KVC实现。 KVO一般代码实现分为三个步骤： 添加观察 @implementation Person - (void)observeNTESStock { [self.stock addObserver:self forKeyPath:@&quot;price&quot; options:NSKeyValueObservingOptionNew context:nil]; } @end 添加回调 - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context { // To Do Something··· } 移除观察 [self.stock removeObserver:self forKeyPath:@&quot;price&quot;]; 但是KVO在使用中也有一些问题： 由于观察者可以观察多个键值，当观察的键值比较多的时候，在回调的方法中会存在大量的if语句去判断被观察者以及KeyPath 需要手动移除观察，操作不当容易Crash 可重复添加观察（导致多次回调），当移除观察方法 &gt; 添加观察方法的次数时，会crash 在多线程并发下，可能存在这样的问题： 线程一：观察者正在执行dealloc方法，并且还未执行removeObserver 线程二：被观察对象的键值发现改变，触发了KVO的observeValueForKeyPath回调，但此时观察者已经变成野指针了 KVOController介绍 KVOController是FaceBook开源的基于KVO封装的框架，提高了代码的可读性和安全性。下图是其在Github上的介绍： 引入KVOController以后，键值观察的实现将变得非常简单。 @interface ViewController () @property (nonatomic, strong) FBKVOController *KVOController; @end @implementation ViewController - (void)viewDidLoad { [super viewDidLoad]; self.KVOController = [[FBKVOController alloc] initWithObserver:self]; Person *person = [[Person alloc] init]; [self.KVOController observe:person keyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew block:^(id _Nullable observer, id _Nonnull object, NSDictionary&lt;NSKeyValueChangeKey,id&gt; * _Nonnull change) { NSLog(@&quot;%@&quot;, change); }]; person.name = @&quot;Jane&quot;; } @end =====输出===== { FBKVONotificationKeyPathKey = name; kind = 1; new = Jane; } KVOController提供了Block、Action、原生方法三种回调方法。 KVOController也对NSObject做了category，动态绑定了KVOController属性，使用起来更方便。 KVOController源码分析 KVOController的源码非常少，一共五个文件。 NSObject+FBKVOController主要是动态增加了NSObject的两个属性，区别在于是否持有被观察对象的强引用，它们都采用了懒加载。 @interface NSObject (FBKVOController) @property (nonatomic, strong) FBKVOController *KVOController; @property (nonatomic, strong) FBKVOController *KVOControllerNonRetaining; @end static void *NSObjectKVOControllerKey = &amp;NSObjectKVOControllerKey; static void *NSObjectKVOControllerNonRetainingKey = &amp;NSObjectKVOControllerNonRetainingKey; @implementation NSObject (FBKVOController) - (FBKVOController *)KVOController { id controller = objc_getAssociatedObject(self, NSObjectKVOControllerKey); // lazily create the KVOController if (nil == controller) { controller = [FBKVOController controllerWithObserver:self]; self.KVOController = controller; } return controller; } - (void)setKVOController:(FBKVOController *)KVOController { objc_setAssociatedObject(self, NSObjectKVOControllerKey, KVOController, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (FBKVOController *)KVOControllerNonRetaining { id controller = objc_getAssociatedObject(self, NSObjectKVOControllerNonRetainingKey); if (nil == controller) { controller = [[FBKVOController alloc] initWithObserver:self retainObserved:NO]; self.KVOControllerNonRetaining = controller; } return controller; } - (void)setKVOControllerNonRetaining:(FBKVOController *)KVOControllerNonRetaining { objc_setAssociatedObject(self, NSObjectKVOControllerNonRetainingKey, KVOControllerNonRetaining, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } @end 初始化与销毁代码 FBKVOController内的属性_objectInfosMap 根据retainObserved是YES还是NO，在初始化时选择对Key值进行强引用还是弱引用。_objectInfosMap的Key记录了被观察者，Value记录了被观察者的所有FBKVOInfo集合。 下图描述了KVOController和KVOInfo的关系： KVOController把观察的键值路径、回调block等信息封装到一个KVOInfo中，内部重写了hash和isEqual方法。 添加观察者 这里以Block的为例。首先将参数封装到FBKVOInfo中，然后调用内部的_observe:info方法 内部的_observe:info方法，将FBKVOInfo加入到对应object的集合中。最后调用了_FBKVOSharedController的方法，这个FBKVOSharedController采用单例实现，所有的FBKVOController共享。 在这里，可以看到调用了原生的addObserver方法了。 Observer指定为self，所以当键值发生变化时，就会回调这个FBKVOSharedController里面的方法。这里会依次判断FBKVOInfo中是否有Block、Action、默认回调方法，选择一个执行。 使用了KVOController进行键值监听的，所有的回调都会回到KVOSharedController这个类中，然后在根据KVOInfo里面的信息进行转发。 移除观察者的流程和上面类似，这里不再展开。 KVOController注意事项 虽然KVOController已经修复了KVO的一些问题，但是如果用得不恰当，还是会有Crash发生。如果在dealloc中第一次调用了KVOController，就会导致Crash。 @implementation SecondViewController - (void)viewDidLoad { [super viewDidLoad]; //模拟一种情况，满足某种条件时才使用KVOController if(arc4random_uniform(4) == 1) { NSLog(@&quot;%@&quot;, self.KVOController); } } - (void)dealloc { [self.KVOController unobserveAll]; } @end 原因也比较简单，KVOController采用了懒加载，在init方法中会把当前对象赋值给其内部属性observer，但是当前对象已经到了dealloc的处理流程，无法赋值。 不过一般也不需要在当前对象的dealloc方法中移除监听，因为KVOController的dealloc方法已经做了这样的处理。 又比如当观察的对象是本身时，需要注意避免出现循环引用。 KVO的基本原理 KVOController本质是对原有KVO的封装，那么原有KVO又是如何实现的呢？ 苹果文档中对其进行了描述： Automatic key-value observing is implemented using a technique called isa-swizzling. The isa pointer, as the name suggests, points to the object's class which maintains a dispatch table. This dispatch table essentially contains pointers to the methods the class implements, among other data. When an observer is registered for an attribute of an object the isa pointer of the observed object is modified, pointing to an intermediate class rather than at the true class. As a result the value of the isa pointer does not necessarily reflect the actual class of the instance. You should never rely on the isa pointer to determine class membership. Instead, you should use the class method to determine the class of an object instance. 当对象添加了KVO监听之后，系统会修改对象的isa指针，这个过程称为isa-swizzling。新isa指针指向的类是原来的子类，通过运行时机制生成，其中重写了set方法。set方法调用了 Fundation框架中C语言函数 _NSsetIntValueAndNotifyset，这个方法的大致调用逻辑为：调用willChangeValueForKey方法，然后调用原来的set方法，最后调用didChangeValueForKey。其中didChangeValueForKey方法内部调用了observeValueForKeyPath:ofObject:change:context:监听方法。 未添加KVO时 添加KVO之后 下面通过代码调试来验证上面这个结论。 创建一个Person类，里面只有一个age属性 @interface Person : NSObject @property (nonatomic, assign) int age; @end @implementation Person @end 代码中创建两个Person对象p1和p2。首先打印出未添加KVO之前的IMP指针，然后给p1添加KVO，再打印IMP指针。我们会看到，在添加KVO监听之后，p1的setAge方法的IMP已经变了。 把这两个IMP打印出来，发现p1的已经变成了NSSetIntValueAndNotify。 下面我们看一下p1指向的类是否已经改变，并查看该类的内部结构。 可以看到，p1指向的类已经变为NSKVONotifying_Person，里面有四个方法。 为什么有class方法，主要是为了对外屏蔽这个子类的存在。要取得真实的class类型，需要通过object_getClass的方式 下面验证didChangeValueForKey:内部会调用observer的observeValueForKeyPath:ofObject:change:context:方法 知道这个特点后，我们甚至可以在不更新属性的情况下调用KVO回调方法。不过我们一般不会直接这么做，而是先通过+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey置为NO，表示手动触发KVO。 扩展阅读 KVO位于Foundation框架中，而这部分代码苹果没有开源。不过我们可以参考GNU Step中的相关实现逻辑。 GNU Step的代码可以从这里获取：https://github.com/gnustep/libs-base 这里简单介绍一下其中的逻辑。如下图所示，A观察B中price的变化，C观察B中price和name的变化。KVO会为每一个对象关联一份GSKVOInfo，里面Key为属性名，Value为GSKVOPathInfo，GSKVOPathInfo内部包含一个GSKVOObservation构成的数组，里面弱引用着A和C。 当然，除了参考GNU Step里面的写法，我们也可以自己仿造写一个KVO。 这里我写了一个例子：https://github.com/jayying007/demo-KVO 总结 本篇介绍了KVO以及其实现原理，针对KVO在开发过程中的问题，介绍了更好的替代方式--采用KVOController。 另外，对一些常见的问题我们也能解答： 设置成员变量 _age，没有触发 setter 方法 ，也不会触发 KVO 相关的代码； 一个被声明为public的变量，而不是类的属性，只要其拥有对应的setter方法，也可以触发KVO； 当观察的键值比较复杂，比如Person的dog.name的时候，动态生成的类包含Person和Dog，即Person的dog属性和Dog的name属性变化时，都会触发KVO； 通过setValue:ForKey的方式也可以触发KVO，因为其逻辑就是找setXXX，_setXXX这些方法。 参考资料 你的KVO用对了吗 KVOController源码 苹果官方KVO文档 如何优雅地使用KVO KVO底层实现原理 ","link":"https://jayying007.github.io/post/KVO&KVOController及其原理/"},{"title":"搭建个人博客","content":"服务器选购 我这次采用的是腾讯云，因为我有几百块的代金劵，哈哈。 操作系统：Ubuntu 20.04 LTS 硬件配置：1核 2GB 2Mbps 系统配置 通过SSH获取密码登录系统，然后需要修改一下DNS服务器的配置。 默认好像开启了systemd-resolved这个服务，一开始一直解析不了DNS。 关于systemd-resolved，可以参考这篇文章：https://www.freedomwolf.cc/2020/01/dns_by_systemd/ 在/etc/systemd/resolved.conf中，把#DNS= 改为DNS=1.1.1.1，然后重启服务就可以了。 sudo systemctl restart systemd-resolved.service 然而，现在是可以ping www.baidu.com了，但是tencent内部的一些域名就解析不了了。 当我执行sudo apt-get update的时候，会出现下面这段内容 Err:1 http://mirrors.tencentyun.com/ubuntu focal InRelease Something wicked happened resolving 'mirrors.tencentyun.com:http' (-5 - No address associated with hostname) Err:2 http://mirrors.tencentyun.com/ubuntu focal-security InRelease Something wicked happened resolving 'mirrors.tencentyun.com:http' (-5 - No address associated with hostname) Err:3 http://mirrors.tencentyun.com/ubuntu focal-updates InRelease Something wicked happened resolving 'mirrors.tencentyun.com:http' (-5 - No address associated with hostname) Reading package lists... Done W: Failed to fetch http://mirrors.tencentyun.com/ubuntu/dists/focal/InRelease Something wicked happened resolving 'mirrors.tencentyun.com:http' (-5 - No address associated with hostname) W: Failed to fetch http://mirrors.tencentyun.com/ubuntu/dists/focal-security/InRelease Something wicked happened resolving 'mirrors.tencentyun.com:http' (-5 - No address associated with hostname) W: Failed to fetch http://mirrors.tencentyun.com/ubuntu/dists/focal-updates/InRelease Something wicked happened resolving 'mirrors.tencentyun.com:http' (-5 - No address associated with hostname) W: Some index files failed to download. They have been ignored, or old ones used instead. 一种方法是修改apt的镜像源，在/etc/apt/sources.list中配置其他镜像地址 另外就是使用腾讯的DNS服务器了。在https://cloud.tencent.com/document/product/213/5225这里找。 我的是广州六区，找不到，问了一下客服，选择了“私有网络-所有地域”这个类型的ip地址，然后就可以了。 Wordpress的搭建 这个根据某位博主的指引，找到了一个不错的视频教程 https://www.bilibili.com/video/BV1j4411C7Qf 之前用WordPress搭建了一遍，但是感觉WordPress对代码和markdown的支持不太好，后面就改换Hexo了。 如何安装Hexo可以在官网得到详细的教程，所以这里不打算展开讲，下面讲讲官网没提到的。 官网有的内容 如何安装Hexo框架 如何建网站、建文章、本地发布 我要讲的 博客主题 这里我选择了NexT，比较简洁，地址：https://theme-next.js.org，网站里面也介绍了如何配置各种东西。 如果你不清楚某一个配置项如何实现的，可以在评论区留言 增加分类和标签页面 在source里面增加categories和tags两个文件夹，里面都添加一个index.md文件，内容分别为： --- title: categories date: 2021-06-13 10:16:14 type: categories --- --- title: tags date: 2021-06-13 09:10:25 type: tags --- 最后记得在NexT的配置中开启这两个，比如我当前的配置如下： menu: home: / || fa fa-home #about: /about/ || fa fa-user tags: /tags/ || fa fa-tags categories: /categories/ || fa fa-th archives: /archives/ || fa fa-archive #schedule: /schedule/ || fa fa-calendar #sitemap: /sitemap.xml || fa fa-sitemap #commonweal: /404/ || fa fa-heartbeat 部署到服务器上 这里采用Git的方式部署，首先需要安装Git部署插件 npm install hexo-deployer-git --save 本地配置添加（IP改为你的服务器地址，同时要先配置好SSH，比如我本地配置了SSH免密登陆服务器，不然每次都需要输入密码，当然这也看你个人意愿） deploy: type: git repo: ubuntu@11.22.33.44:/home/ubuntu/hexo branch: master 然后在服务器上面创建一个hexo的git仓库 写博客的几个步骤： hexo new 'new blog title' 写内容... hexo clean hexo generate hexo deploy 如果你按我上面说的，当你deploy的时候，会出错 On branch master nothing to commit, working tree clean Enumerating objects: 90, done. Counting objects: 100% (90/90), done. Delta compression using up to 8 threads Compressing objects: 100% (77/77), done. Writing objects: 100% (90/90), 54.96 KiB | 3.92 MiB/s, done. Total 90 (delta 15), reused 0 (delta 0), pack-reused 0 remote: error: refusing to update checked out branch: refs/heads/master remote: error: By default, updating the current branch in a non-bare repository remote: is denied, because it will make the index and work tree inconsistent remote: with what you pushed, and will require 'git reset --hard' to match remote: the work tree to HEAD. remote: remote: You can set the 'receive.denyCurrentBranch' configuration variable remote: to 'ignore' or 'warn' in the remote repository to allow pushing into remote: its current branch; however, this is not recommended unless you remote: arranged to update its work tree to match what you pushed in some remote: other way. remote: remote: To squelch this message and still keep the default behaviour, set remote: 'receive.denyCurrentBranch' configuration variable to 'refuse'. To 159.75.249.140:/home/ubuntu/hexo ! [remote rejected] HEAD -&gt; master (branch is currently checked out) error: failed to push some refs to '159.75.249.140:/home/ubuntu/hexo' FATAL { err: Error: Spawn failed at ChildProcess.&lt;anonymous&gt; (/Users/jieyingzhuang/Desktop/blog/node_modules/hexo-util/lib/spawn.js:51:21) at ChildProcess.emit (node:events:394:28) at Process.ChildProcess._handle.onexit (node:internal/child_process:290:12) { code: 1 } } Something's wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html 你可以按照提示输入命令git config receive.denyCurrentBranch ignore解决，这里我采用另一种方法解决： 创建裸仓库，和代码文件分开存放 创建一个叫hexo.git的裸仓库，所以hexo的配置信息也要换成hexo.git，创建hexo空文件夹。然后添加钩子post-receive并设置为可执行文件，里面的内容为 git --work-tree=/home/ubuntu/hexo --git-dir=/home/ubuntu/hexo.git checkout -f 这样，当你deploy的时候，会把网站的内容到存到hexo文件夹中。后面你还需要配置服务器，用Apache或者Nginx，然后指定网站的根目录为hexo，即可正常访问。 没讲的东西 感觉属于其他方面的知识，我就没有细说。这些也可以找其他博客看看。 SSH免密登陆 配置Nginx服务器（配置SSL证书） Hexo具体的配置信息（主要看各自喜好） ","link":"https://jayying007.github.io/post/搭建个人博客/"}]}